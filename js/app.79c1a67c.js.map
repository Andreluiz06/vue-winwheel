{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/App.vue?5b85","webpack:///./src/VueWinwheel.vue?81f7","webpack:///./src/App.vue?655f","webpack:///./src/VueWinwheel.vue?28ac","webpack:///src/VueWinwheel.vue","webpack:///./src/VueWinwheel.vue?e247","webpack:///./src/VueWinwheel.vue","webpack:///src/App.vue","webpack:///./src/App.vue?8b47","webpack:///./src/App.vue","webpack:///./src/main.js","webpack:///./src/Winwheel.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","app","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_VueWinwheel_vue_vue_type_style_index_0_id_12d1e501_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_VueWinwheel_vue_vue_type_style_index_0_id_12d1e501_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default","render","_vm","this","_h","$createElement","_c","_self","attrs","id","staticRenderFns","VueWinwheelvue_type_template_id_12d1e501_scoped_true_render","staticClass","_v","_m","loadingPrize","wheelSpinning","_e","href","on","click","$event","preventDefault","startSpin","slot","hidePrize","_s","prizeName","VueWinwheelvue_type_template_id_12d1e501_scoped_true_staticRenderFns","width","height","staticStyle","{color","align","VueWinwheelvue_type_script_lang_js_","props","segments","[object Object]","textFillStyle","fillStyle","text","theWheel","modalPrize","wheelPower","WinWheelOptions","textFontSize","outterRadius","innerRadius","lineWidth","animation","type","duration","methods","startAnimation","Winwheel","numSegments","spins","callbackFinished","onFinishSpin","prizeNumber","Math","floor","random","stopAt","stopAngle","stopAnimation","rotationAngle","draw","resetWheel","indicatedSegment","showPrize","computed","initSpin","src_VueWinwheelvue_type_script_lang_js_","component","componentNormalizer","options","__file","VueWinwheel","Appvue_type_script_lang_js_","components","src_Appvue_type_script_lang_js_","App_component","App","vue_runtime_esm","config","productionTip","h","$mount","__webpack_exports__","gsap__WEBPACK_IMPORTED_MODULE_0__","drawWheel","defaultOptions","canvasId","centerX","centerY","outerRadius","drawMode","textFontFamily","textFontWeight","textOrientation","textAlignment","textDirection","textMargin","textStrokeStyle","textLineWidth","strokeStyle","clearTheCanvas","imageOverlay","drawText","pointerAngle","wheelImage","imageDirection","canvas","document","getElementById","ctx","getContext","cavnas","Array","x","Segment","updateSegmentSizes","Animation","pins","Pin","pointerGuide","PointerGuide","winwheelToDrawDuringAnimation","winhweelAlreadyDrawn","y","image","imgData","Image","onload","winwheelLoadedImage","src","arcUsed","numSet","size","arcLeft","degreesEach","currentDegree","startAngle","endAngle","clearRect","clearCanvas","drawWheelImage","drawSegmentText","drawSegments","drawSegmentImages","visible","drawPins","display","drawPointerGuide","number","pinSpacing","save","translate","rotate","degToRad","beginPath","arc","margin","PI","fill","stroke","restore","moveTo","lineTo","imageLeft","imageTop","drawImage","seg","imageAngle","console","log","fontFamily","fontSize","fontWeight","orientation","alignment","direction","fontSetting","font","lines","split","lineOffset","textAlign","textBaseline","textAngle","fillText","strokeText","yPos","yInc","character","charAt","centerAdjustment","radius","anglePerChar","drawAngle","radiusPercent","totalArc","position","segmentPos","newSegment","undefined","bbox","getBoundingClientRect","left","top","foundSegment","segmentNumber","getSegmentNumberAt","topBottom","leftRight","adjacentSideLength","oppositeSideLength","hypotenuseSideLength","loc","windowToCanvas","tanVal","atan","locationAngle","sqrt","round","rotatedPosition","getRotationPosition","abs","foundSegmentNumber","getIndicatedSegmentNumber","indicatedPrize","rawAngle","relativeAngle","currentPin","totalPinAngle","timesPast360","ceil","computeAnimation","properties","propertyName","propertyValue","yoyo","repeat","easing","winwheelAnimationLoop","winwheelStopAnimation","tween","to","canCallback","kill","pause","play","_stopAngle","range","callbackBefore","callbackAfter","callbackSound","soundTrigger","winwheelPercentToDegrees","percentValue","degrees","divider","eval","winwheelTriggerSound","_lastSoundTriggerNumber","currentTriggerNumber","getCurrentPinNumber","callback","getIndicatedSegment","winwheelImageLoadCount"],"mappings":"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","file":"js/app.79c1a67c.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","import mod from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../node_modules/css-loader/index.js??ref--6-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=style&index=0&lang=css&\"; export default mod; export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../node_modules/css-loader/index.js??ref--6-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=style&index=0&lang=css&\"","import mod from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../node_modules/css-loader/index.js??ref--6-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./VueWinwheel.vue?vue&type=style&index=0&id=12d1e501&scoped=true&lang=css&\"; export default mod; export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../node_modules/css-loader/index.js??ref--6-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./VueWinwheel.vue?vue&type=style&index=0&id=12d1e501&scoped=true&lang=css&\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"app\"}},[_c('vue-winwheel')],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',{staticClass:\"vue-winwheel\"},[_c('div',{staticClass:\"mobile-container\"},[_c('h1',[_vm._v(\"Vue-Winwheel\")]),_c('div',{staticClass:\"wheel-wrapper\"},[_vm._m(0),_c('div',{staticClass:\"button-wrapper\"},[(!_vm.loadingPrize && !_vm.wheelSpinning)?_c('a',{staticClass:\"btn btn-play\",attrs:{\"href\":\"#\"},on:{\"click\":function($event){$event.preventDefault();_vm.startSpin()}}},[_vm._v(\"SPIN!\")]):_vm._e()])])]),(_vm.modalPrize)?_c('div',{staticClass:\"custom-modal modal-mask\",attrs:{\"id\":\"modalSpinwheel\"}},[_c('div',{attrs:{\"slot\":\"body\"},slot:\"body\"},[_c('a',{staticClass:\"modal-dismiss\",attrs:{\"href\":\"\"},on:{\"click\":function($event){$event.preventDefault();_vm.hidePrize()}}},[_c('i',{staticClass:\"icon_close\"})]),_c('h2',[_vm._v(\"\\n\\t\\t\\t\\tYay you got the prize!!\\n\\t\\t\\t\")]),_c('h1',[_vm._v(\" \"+_vm._s(_vm.prizeName))])])]):_vm._e()])}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"canvas-wrapper\"},[_c('canvas',{attrs:{\"id\":\"canvas\",\"width\":\"310\",\"height\":\"310\"}},[_c('p',{staticStyle:{\"{color\":\"white}\"},attrs:{\"align\":\"center\"}},[_vm._v(\"Sorry, your browser doesn't support canvas. Please try Google Chrome.\")])])])}]\n\nexport { render, staticRenderFns }","<template>\n\t\t<section class=\"vue-winwheel\">\n\t\t\t<div class=\"mobile-container\">\n\t\t\t\t<h1>Vue-Winwheel</h1>\n\t\t\t\t<div class=\"wheel-wrapper\">\n\t\t\t\t\t<div class=\"canvas-wrapper\">\n\t\t\t\t\t\t<canvas id=\"canvas\" width=\"310\" height=\"310\">\n\t\t\t\t\t\t\t<p style=\"{color: white}\" align=\"center\">Sorry, your browser doesn't support canvas. Please try Google Chrome.</p>\n\t\t\t\t\t\t</canvas>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"button-wrapper\">\n\t\t\t\t\t\t<a class=\"btn btn-play\" href=\"#\" @click.prevent=\"startSpin()\" v-if=\"!loadingPrize && !wheelSpinning\">SPIN!</a>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div class=\"custom-modal modal-mask\" id=\"modalSpinwheel\" v-if=\"modalPrize\">\n\t\t\t\t<div slot=\"body\">\n\t\t\t\t\t<a href=\"\" @click.prevent=\"hidePrize()\" class=\"modal-dismiss\">\n\t\t\t\t\t\t<i class=\"icon_close\"></i>\n\t\t\t\t\t</a>\n\t\t\t\t\t<h2>\n\t\t\t\t\t\tYay you got the prize!!\n\t\t\t\t\t</h2>\n\t\t\t\t\t<h1> {{prizeName}}</h1>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</section>\n</template>\n\n\n<script>\nimport * as Winwheel from './Winwheel'\n\nexport default {\n  name: 'VueWinWheel',\n  props:{\n\t\tsegments:{\n\t\t\tdefault(){\n\t\t\t\treturn [\n\t\t\t\t\t{\n\t\t\t\t\t\ttextFillStyle: '#fff',\n\t\t\t\t\t\tfillStyle: '#000',\n\t\t\t\t\t\ttext:'Prize 1'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttextFillStyle: '#000',\n\t\t\t\t\t\tfillStyle: '#fadede',\n\t\t\t\t\t\ttext:'Prize 2'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttextFillStyle: '#fff',\n\t\t\t\t\t\tfillStyle: '#000',\n\t\t\t\t\t\ttext:'Prize 3'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttextFillStyle: '#000',\n\t\t\t\t\t\tfillStyle: '#fadede',\n\t\t\t\t\t\ttext:'Prize 4'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttextFillStyle: '#fff',\n\t\t\t\t\t\tfillStyle: '#000',\n\t\t\t\t\t\ttext:'Prize 5'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttextFillStyle: '#000',\n\t\t\t\t\t\tfillStyle: '#fadede',\n\t\t\t\t\t\ttext:'Prize 6'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttextFillStyle: '#fff',\n\t\t\t\t\t\tfillStyle: '#000',\n\t\t\t\t\t\ttext:'Prize 7'\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttextFillStyle: '#000',\n\t\t\t\t\t\tfillStyle: '#fadede',\n\t\t\t\t\t\ttext:'Prize 8'\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}\n  },\n  data () {\n    return {\n      loadingPrize: false,\n      theWheel: null,\n      modalPrize: false,\n      wheelPower: 1,\n      wheelSpinning: false,\n      prizeName: 'BUY 1 GET 1',\n      WinWheelOptions: {\n        textFontSize: 14,\n        outterRadius: 410,\n        innerRadius: 25,\n        lineWidth: 8,\n        animation: {\n          type: 'spinOngoing',\n          duration: 0.5\n        }\n      }\n    }\n  },\n  methods: {\n    showPrize () {\n      this.modalPrize = true\n    },\n    hidePrize () {\n      this.modalPrize = false\n    },\n    startSpin () {\n      if (this.wheelSpinning === false) {\n        this.theWheel.startAnimation()\n        this.wheelSpinning = true\n        this.theWheel = new Winwheel.Winwheel({\n          ...this.WinWheelOptions,\n          numSegments: this.segments.length,\n          segments: this.segments,\n          animation: {\n            type: 'spinToStop',\n            duration: 5,\n            spins: 5,\n            callbackFinished: this.onFinishSpin\n          }\n        })\n\n        // example input prize number get from Backend\n        // Important thing is to set the stopAngle of the animation before stating the spin.\n\n        var prizeNumber = Math.floor(Math.random() * this.segments.length) // or just get from Backend\n        var stopAt = 360 / this.segments.length * prizeNumber - 360 / this.segments.length / 2 // center pin\n        // var stopAt = 360 / this.segments.length * prizeNumber - Math.floor(Math.random() * 60) //random location\n        this.theWheel.animation.stopAngle = stopAt\n        this.theWheel.startAnimation()\n        this.wheelSpinning = false\n      }\n    },\n    resetWheel () {\n      this.theWheel = new Winwheel.Winwheel({\n        ...this.WinWheelOptions,\n        numSegments: this.segments.length,\n        segments: this.segments\n      })\n\n      if (this.wheelSpinning) {\n        this.theWheel.stopAnimation(false) // Stop the animation, false as param so does not call callback function.\n      }\n\n      this.theWheel.rotationAngle = 0 // Re-set the wheel angle to 0 degrees.\n      this.theWheel.draw() // Call draw to render changes to the wheel.\n      this.wheelSpinning = false // Reset to false to power buttons and spin can be clicked again.\n    },\n    initSpin () {\n      this.loadingPrize = true\n            this.resetWheel()\n            this.loadingPrize = false\n    },\n    onFinishSpin (indicatedSegment) {\n      this.prizeName = indicatedSegment.text\n      this.showPrize()\n    }\n  },\n  computed: {},\n  updated () {},\n  mounted () {\n    this.initSpin()\n    // this.resetWheel()\n  },\n  created () {}\n}\n\n</script>\n\n<style scoped>\n.vue-winwheel {\n\ttext-align: center;\n\tbackground-image: url('/static/img/obstacle-run/bg-spinner-mobile.svg');\n\tbackground-size: cover;\n\tbackground-position: center bottom;\n\tbackground-repeat: no-repeat;\n}\n.vue-winwheel h1 {\n\tcolor: #b32656;\n\tfont-family: 'Avenir', Helvetica, Arial, sans-serif;\n\tfont-size: 36px;\n\tline-height: 90px;\n\tletter-spacing: 4px;\n\tmargin: 0;\n}\n.vue-winwheel h2 {\n\tmargin: 0;\n}\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content {\n\twidth: calc(100vw - 30px);\n\tpadding-top: 52px;\n}\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content h2 {\n\ttext-transform: uppercase;\n\tcolor: #b32656;\n\tmargin-bottom: 16px;\n\tmargin-top: 0;\n\tfont-family: 'Avenir', Helvetica, Arial, sans-serif;\n\tfont-size: 18px;\n\tletter-spacing: 1.1px;\n\tmargin: 0;\n}\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content p {\n\tfont-family: 'Avenir', Helvetica, Arial, sans-serif;\n\tfont-size: 14px;\n\tcolor: black;\n\ttext-align: center;\n\tline-height: 25px;\n}\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content p strong {\n\tfont-family: 'Avenir', Helvetica, Arial, sans-serif;\n}\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content .modal-dismiss {\n\ttop: 12px;\n\tright: 12px;\n}\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content .modal-dismiss i.icon_close {\n\tfont-size: 30px;\n\tcolor: #da2a52;\n}\n.vue-winwheel canvas#canvas {\n\tposition: relative;\n}\n.vue-winwheel .canvas-wrapper {\n\tposition: relative;\n}\n.vue-winwheel .canvas-wrapper:after {\n\tcontent: '';\n\tdisplay: block;\n\twidth: 42px;\n\tbackground: #c4376f;\n\theight: 42px;\n\tposition: absolute;\n\tleft: calc(50% - 25px);\n\tmargin: auto;\n\tborder-radius: 100%;\n\ttop: calc(50% - 29px);\n\tborder: 5px solid white;\n\tbox-sizing: content-box;\n}\n.vue-winwheel .canvas-wrapper:before {\n\tcontent: '';\n\tdisplay: block;\n\twidth: 310px;\n\tbackground: #0f0f0f;\n\theight: 310px;\n\tposition: absolute;\n\tleft: 0;\n\tright: 0;\n\tmargin: 0 auto;\n\tborder-radius: 100%;\n\ttop: 0;\n}\n.vue-winwheel .wheel-wrapper {\n\tposition: relative;\n}\n.vue-winwheel .wheel-wrapper:before {\n\tcontent: '';\n\twidth: 62px;\n\theight: 47px;\n\tposition: absolute;\n\ttop: -10px;\n\tleft: calc(50% - 31px);\n\tright: 0;\n\tdisplay: block;\n\tz-index: 99999;\n\tbackground-image: url('./spinner-marker.svg');\n\tbackground-repeat: no-repeat;\n\tbackground-size: contain;\n\tbackground-position: center;\n}\n.vue-winwheel .wheel-wrapper .button-wrapper {\n\tmargin: 0 auto;\n\tdisplay: flex;\n\tflex-direction: column;\n\talign-items: center;\n\tjustify-content: center;\n\twidth: 231px;\n\theight: 118px;\n}\n.vue-winwheel .wheel-wrapper .btn.btn-play {\n\tpadding: 0 58px !important;\n\tbackground: #c4376f;\n\theight: 40px;\n\tline-height: 40px;\n\tcolor: white;\n\tfont-weight: bold;\n\ttext-decoration: none;\n\tborder-radius: 2px;\n\tfont-family: 'Avenir', Helvetica, Arial, sans-serif;\n\tletter-spacing: 2px;\n}\n</style>\n","import mod from \"-!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./VueWinwheel.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./VueWinwheel.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./VueWinwheel.vue?vue&type=template&id=12d1e501&scoped=true&\"\nimport script from \"./VueWinwheel.vue?vue&type=script&lang=js&\"\nexport * from \"./VueWinwheel.vue?vue&type=script&lang=js&\"\nimport style0 from \"./VueWinwheel.vue?vue&type=style&index=0&id=12d1e501&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"12d1e501\",\n  null\n  \n)\n\ncomponent.options.__file = \"VueWinwheel.vue\"\nexport default component.exports","<template>\n  <div id=\"app\">\n    <vue-winwheel />\n  </div>\n</template>\n\n<script>\nimport VueWinwheel from './VueWinwheel.vue'\n\nexport default {\n  name: 'app',\n  components: {\n    VueWinwheel\n  }\n}\n</script>\n\n<style>\n#app {\n  font-family: 'Avenir', Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n</style>\n","import mod from \"-!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./App.vue?vue&type=template&id=129b94fd&\"\nimport script from \"./App.vue?vue&type=script&lang=js&\"\nexport * from \"./App.vue?vue&type=script&lang=js&\"\nimport style0 from \"./App.vue?vue&type=style&index=0&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\ncomponent.options.__file = \"App.vue\"\nexport default component.exports","import Vue from 'vue'\nimport App from './App.vue'\n\nVue.config.productionTip = false\n\nnew Vue({\n  render: function (h) { return h(App) },\n}).$mount('#app')\n","import { TweenMax } from 'gsap'\n\nexport class Winwheel {\n\tconstructor(options, drawWheel) {\n\t\tvar defaultOptions = {\n\t\t\tcanvasId: 'canvas', // Id of the canvas which the wheel is to draw on to.\n\t\t\tcenterX: null, // X position of the center of the wheel. The default of these are null which means will be placed in center of the canvas.\n\t\t\tcenterY: null, // Y position of the wheel center. If left null at time of construct the center of the canvas is used.\n\t\t\touterRadius: null, // The radius of the outside of the wheel. If left null it will be set to the radius from the center of the canvas to its shortest side.\n\t\t\tinnerRadius: 0, // Normally 0. Allows the creation of rings / doughnuts if set to value > 0. Should not exceed outer radius.\n\t\t\tnumSegments: 1, // The number of segments. Need at least one to draw.\n\t\t\tdrawMode: 'code', // The draw mode. Possible values are 'code', 'image', 'segmentImage'. Default is code which means segments are drawn using canvas arc() function.\n\t\t\trotationAngle: 0, // The angle of rotation of the wheel - 0 is 12 o'clock position.\n\t\t\ttextFontFamily: 'sans-serif', // Segment text font, you should use web safe fonts.\n\t\t\ttextFontSize: 13, // Size of the segment text.\n\t\t\ttextFontWeight: 'bold', // Font weight.\n\t\t\ttextOrientation: 'horizontal', // Either horizontal, vertical, or curved.\n\t\t\ttextAlignment: 'center', // Either center, inner, or outer.\n\t\t\ttextDirection: 'normal', // Either normal or reversed. In normal mode for horizontal text in segment at 3 o'clock is correct way up, in reversed text at 9 o'clock segment is correct way up.\n\t\t\ttextMargin: null, // Margin between the inner or outer of the wheel (depends on textAlignment).\n\t\t\ttextFillStyle: 'black', // This is basically the text colour.\n\t\t\ttextStrokeStyle: null, // Basically the line colour for segment text, only looks good for large text so off by default.\n\t\t\ttextLineWidth: 1, // Width of the lines around the text. Even though this defaults to 1, a line is only drawn if textStrokeStyle specified.\n\t\t\tfillStyle: 'silver', // The segment background colour.\n\t\t\tstrokeStyle: null, // Segment line colour. Again segment lines only drawn if this is specified.\n\t\t\tlineWidth: 1, // Width of lines around segments.\n\t\t\tclearTheCanvas: true, // When set to true the canvas will be cleared before the wheel is drawn.\n\t\t\timageOverlay: false, // If set to true in image drawing mode the outline of the segments will be displayed over the image. Does nothing in code drawMode.\n\t\t\tdrawText: true, // By default the text of the segments is rendered in code drawMode and not in image drawMode.\n\t\t\tpointerAngle: 0, // Location of the pointer that indicates the prize when wheel has stopped. Default is 0 so the (corrected) 12 o'clock position.\n\t\t\twheelImage: null, // Must be set to image data in order to use image to draw the wheel - drawMode must also be 'image'.\n\t\t\timageDirection: 'N', // Used when drawMode is segmentImage. Default is north, can also be (E)ast, (S)outh, (W)est.\n\t\t}\n\n\t\t// -----------------------------------------\n\t\t// Loop through the default options and create properties of this class set to the value for the option passed in\n\t\t// or if not value for the option was passed in then to the default.\n\t\tfor (var key in defaultOptions) {\n\t\t\tif (options != null && typeof options[key] !== 'undefined') {\n\t\t\t\tthis[key] = options[key]\n\t\t\t} else {\n\t\t\t\tthis[key] = defaultOptions[key]\n\t\t\t}\n\t\t}\n\n\t\t// Also loop though the passed in options and add anything specified not part of the class in to it as a property.\n\t\tif (options != null) {\n\t\t\tfor (var key in options) {\n\t\t\t\tif (typeof this[key] === 'undefined') {\n\t\t\t\t\tthis[key] = options[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// If the id of the canvas is set, try to get the canvas as we need it for drawing.\n\t\tif (this.canvasId) {\n\t\t\tthis.canvas = document.getElementById(this.canvasId)\n\n\t\t\tif (this.canvas) {\n\t\t\t\t// If the centerX and centerY have not been specified in the options then default to center of the canvas\n\t\t\t\t// and make the outerRadius half of the canvas width - this means the wheel will fill the canvas.\n\t\t\t\tif (this.centerX == null) {\n\t\t\t\t\tthis.centerX = this.canvas.width / 2\n\t\t\t\t}\n\n\t\t\t\tif (this.centerY == null) {\n\t\t\t\t\tthis.centerY = this.canvas.height / 2\n\t\t\t\t}\n\n\t\t\t\tif (this.outerRadius == null) {\n\t\t\t\t\t// Need to set to half the width of the shortest dimension of the canvas as the canvas may not be square.\n\t\t\t\t\t// Minus the line segment line width otherwise the lines around the segments on the top,left,bottom,right\n\t\t\t\t\t// side are chopped by the edge of the canvas.\n\t\t\t\t\tif (this.canvas.width < this.canvas.height) {\n\t\t\t\t\t\tthis.outerRadius = this.canvas.width / 2 - this.lineWidth\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.outerRadius = this.canvas.height / 2 - this.lineWidth\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Also get a 2D context to the canvas as we need this to draw with.\n\t\t\t\tthis.ctx = this.canvas.getContext('2d')\n\t\t\t} else {\n\t\t\t\tthis.canvas = null\n\t\t\t\tthis.ctx = null\n\t\t\t}\n\t\t} else {\n\t\t\tthis.cavnas = null\n\t\t\tthis.ctx = null\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// Add array of segments to the wheel, then populate with segments if number of segments is specified for this object.\n\t\tthis.segments = new Array(null)\n\n\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t// If options for the segments have been specified then create a segment sending these options so\n\t\t\t// the specified values are used instead of the defaults.\n\t\t\tif (options != null && options['segments'] && typeof options['segments'][x - 1] !== 'undefined') {\n\t\t\t\tthis.segments[x] = new Segment(options['segments'][x - 1])\n\t\t\t} else {\n\t\t\t\tthis.segments[x] = new Segment()\n\t\t\t}\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// Call function to update the segment sizes setting the starting and ending angles.\n\t\tthis.updateSegmentSizes()\n\n\t\t// If the text margin is null then set to same as font size as we want some by default.\n\t\tif (this.textMargin === null) {\n\t\t\tthis.textMargin = this.textFontSize / 1.7\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// If the animation options have been passed in then create animation object as a property of this class\n\t\t// and pass the options to it so the animation is set. Otherwise create default animation object.\n\t\tif (options != null && options['animation'] && typeof options['animation'] !== 'undefined') {\n\t\t\tthis.animation = new Animation(options['animation'])\n\t\t} else {\n\t\t\tthis.animation = new Animation()\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// If some pin options then create create a pin object and then pass them in.\n\t\tif (options != null && options['pins'] && typeof options['pins'] !== 'undefined') {\n\t\t\tthis.pins = new Pin(options['pins'])\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// On that note, if the drawMode is image change some defaults provided a value has not been specified.\n\t\tif (this.drawMode == 'image' || this.drawMode == 'segmentImage') {\n\t\t\t// Remove grey fillStyle.\n\t\t\tif (typeof options['fillStyle'] === 'undefined') {\n\t\t\t\tthis.fillStyle = null\n\t\t\t}\n\n\t\t\t// Set strokeStyle to red.\n\t\t\tif (typeof options['strokeStyle'] === 'undefined') {\n\t\t\t\tthis.strokeStyle = 'red'\n\t\t\t}\n\n\t\t\t// Set drawText to false as we will assume any text is part of the image.\n\t\t\tif (typeof options['drawText'] === 'undefined') {\n\t\t\t\tthis.drawText = false\n\t\t\t}\n\n\t\t\t// Also set the lineWidth to 1 so that segment overlay will look correct.\n\t\t\tif (typeof options['lineWidth'] === 'undefined') {\n\t\t\t\tthis.lineWidth = 1\n\t\t\t}\n\n\t\t\t// Set drawWheel to false as normally the image needs to be loaded first.\n\t\t\tif (typeof drawWheel === 'undefined') {\n\t\t\t\tdrawWheel = false\n\t\t\t}\n\t\t} else {\n\t\t\t// When in code drawMode the default is the wheel will draw.\n\t\t\tif (typeof drawWheel === 'undefined') {\n\t\t\t\tdrawWheel = true\n\t\t\t}\n\t\t}\n\n\t\t// Create pointer guide.\n\t\tif (options != null && options['pointerGuide'] && typeof options['pointerGuide'] !== 'undefined') {\n\t\t\tthis.pointerGuide = new PointerGuide(options['pointerGuide'])\n\t\t} else {\n\t\t\tthis.pointerGuide = new PointerGuide()\n\t\t}\n\n\t\t// Finally if drawWheel is true then call function to render the wheel, segment text, overlay etc.\n\t\tif (drawWheel == true) {\n\t\t\tthis.draw(this.clearTheCanvas)\n\t\t} else if (this.drawMode == 'segmentImage') {\n\t\t\t// If segment image then loop though all the segments and load the images for them setting a callback\n\t\t\t// which will call the draw function of the wheel once all the images have been loaded.\n\t\t\twinwheelToDrawDuringAnimation = this\n\t\t\twinhweelAlreadyDrawn = false\n\n\t\t\tfor (var y = 1; y <= this.numSegments; y++) {\n\t\t\t\tif (this.segments[y].image !== null) {\n\t\t\t\t\tthis.segments[y].imgData = new Image()\n\t\t\t\t\tthis.segments[y].imgData.onload = winwheelLoadedImage\n\t\t\t\t\tthis.segments[y].imgData.src = this.segments[y].image\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function sorts out the segment sizes. Some segments may have set sizes, for the others what is left out of\n\t// 360 degrees is shared evenly. What this function actually does is set the start and end angle of the arcs.\n\t// ====================================================================================================================\n\tupdateSegmentSizes() {\n\t\t// If this object actually contains some segments\n\t\tif (this.segments) {\n\t\t\t// First add up the arc used for the segments where the size has been set.\n\t\t\tvar arcUsed = 0\n\t\t\tvar numSet = 0\n\n\t\t\t// Remember, to make it easy to access segments, the position of the segments in the array starts from 1 (not 0).\n\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t\tif (this.segments[x].size !== null) {\n\t\t\t\t\tarcUsed += this.segments[x].size\n\t\t\t\t\tnumSet++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar arcLeft = 360 - arcUsed\n\n\t\t\t// Create variable to hold how much each segment with non-set size will get in terms of degrees.\n\t\t\tvar degreesEach = 0\n\n\t\t\tif (arcLeft > 0) {\n\t\t\t\tdegreesEach = arcLeft / (this.numSegments - numSet)\n\t\t\t}\n\n\t\t\t// ------------------------------------------\n\t\t\t// Now loop though and set the start and end angle of each segment.\n\t\t\tvar currentDegree = 0\n\n\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t\t// Set start angle.\n\t\t\t\tthis.segments[x].startAngle = currentDegree\n\n\t\t\t\t// If the size is set then add this to the current degree to get the end, else add the degreesEach to it.\n\t\t\t\tif (this.segments[x].size) {\n\t\t\t\t\tcurrentDegree += this.segments[x].size\n\t\t\t\t} else {\n\t\t\t\t\tcurrentDegree += degreesEach\n\t\t\t\t}\n\n\t\t\t\t// Set end angle.\n\t\t\t\tthis.segments[x].endAngle = currentDegree\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function clears the canvas. Will wipe anything else which happens to be drawn on it.\n\t// ====================================================================================================================\n\tclearCanvas() {\n\t\tif (this.ctx) {\n\t\t\tthis.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function draws / re-draws the wheel on the canvas therefore rendering any changes.\n\t// ====================================================================================================================\n\tdraw(clearTheCanvas) {\n\t\t// If have the canvas context.\n\t\tif (this.ctx) {\n\t\t\t// Clear the canvas, unless told not to.\n\t\t\tif (typeof clearTheCanvas !== 'undefined') {\n\t\t\t\tif (clearTheCanvas == true) {\n\t\t\t\t\tthis.clearCanvas()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.clearCanvas()\n\t\t\t}\n\n\t\t\t// Call functions to draw the segments and then segment text.\n\t\t\tif (this.drawMode == 'image') {\n\t\t\t\t// Draw the wheel by loading and drawing an image such as a png on the canvas.\n\t\t\t\tthis.drawWheelImage()\n\n\t\t\t\t// If we are to draw the text, do so before the overlay is drawn\n\t\t\t\t// as this allows the overlay to be used to create some interesting effects.\n\t\t\t\tif (this.drawText == true) {\n\t\t\t\t\tthis.drawSegmentText()\n\t\t\t\t}\n\n\t\t\t\t// If image overlay is true then call function to draw the segments over the top of the image.\n\t\t\t\t// This is useful during development to check alignment between where the code thinks the segments are and where they appear on the image.\n\t\t\t\tif (this.imageOverlay == true) {\n\t\t\t\t\tthis.drawSegments()\n\t\t\t\t}\n\t\t\t} else if (this.drawMode == 'segmentImage') {\n\t\t\t\t// Draw the wheel by rendering the image for each segment.\n\t\t\t\tthis.drawSegmentImages()\n\n\t\t\t\t// If we are to draw the text, do so before the overlay is drawn\n\t\t\t\t// as this allows the overlay to be used to create some interesting effects.\n\t\t\t\tif (this.drawText == true) {\n\t\t\t\t\tthis.drawSegmentText()\n\t\t\t\t}\n\n\t\t\t\t// If image overlay is true then call function to draw the segments over the top of the image.\n\t\t\t\t// This is useful during development to check alignment between where the code thinks the segments are and where they appear on the image.\n\t\t\t\tif (this.imageOverlay == true) {\n\t\t\t\t\tthis.drawSegments()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// The default operation is to draw the segments using code via the canvas arc() method.\n\t\t\t\tthis.drawSegments()\n\n\t\t\t\t// The text is drawn on top.\n\t\t\t\tif (this.drawText == true) {\n\t\t\t\t\tthis.drawSegmentText()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this class has pins.\n\t\t\tif (typeof this.pins !== 'undefined') {\n\t\t\t\t// If they are to be visible then draw them.\n\t\t\t\tif (this.pins.visible == true) this.drawPins()\n\t\t\t}\n\n\t\t\t// If pointer guide is display property is set to true then call function to draw the pointer guide.\n\t\t\tif (this.pointerGuide.display == true) {\n\t\t\t\tthis.drawPointerGuide()\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// Draws the pins around the outside of the wheel.\n\t// ====================================================================================================================\n\tdrawPins() {\n\t\tif (this.pins && this.pins.number) {\n\t\t\t// Work out the angle to draw each pin a which is simply 360 / the number of pins as they space evenly around.\n\t\t\t//++ There is a slight oddity with the pins in that there is a pin at 0 and also one at 360 and these will be drawn\n\t\t\t//++ directly over the top of each other. Also pins are 0 indexed which could possibly cause some confusion\n\t\t\t//++ with the getCurrentPin function - for now this is just used for audio so probably not a problem.\n\t\t\tvar pinSpacing = 360 / this.pins.number\n\n\t\t\tfor (var i = 1; i <= this.pins.number; i++) {\n\t\t\t\tthis.ctx.save()\n\n\t\t\t\t// Set the stroke style and line width.\n\t\t\t\tthis.ctx.strokeStyle = this.pins.strokeStyle\n\t\t\t\tthis.ctx.lineWidth = this.pins.lineWidth\n\t\t\t\tthis.ctx.fillStyle = this.pins.fillStyle\n\n\t\t\t\t// Move to the center.\n\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\n\t\t\t\t// Rotate to to the pin location which is i * the pinSpacing.\n\t\t\t\tthis.ctx.rotate(this.degToRad(i * pinSpacing + this.rotationAngle))\n\n\t\t\t\t// Move back out.\n\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t// Create a path for the pin circle.\n\t\t\t\tthis.ctx.beginPath()\n\t\t\t\t// x, y, radius, startAngle, endAngle.\n\t\t\t\tthis.ctx.arc(\n\t\t\t\t\tthis.centerX,\n\t\t\t\t\tthis.centerY - this.outerRadius + this.pins.outerRadius + this.pins.margin,\n\t\t\t\t\tthis.pins.outerRadius,\n\t\t\t\t\t0,\n\t\t\t\t\t2 * Math.PI\n\t\t\t\t)\n\n\t\t\t\tif (this.pins.fillStyle) this.ctx.fill()\n\n\t\t\t\tif (this.pins.strokeStyle) this.ctx.stroke()\n\n\t\t\t\tthis.ctx.restore()\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// Draws a line from the center of the wheel to the outside at the angle where the code thinks the pointer is.\n\t// ====================================================================================================================\n\tdrawPointerGuide() {\n\t\t// If have canvas context.\n\t\tif (this.ctx) {\n\t\t\tthis.ctx.save()\n\n\t\t\t// Rotate the canvas to the line goes towards the location of the pointer.\n\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\tthis.ctx.rotate(this.degToRad(this.pointerAngle))\n\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t// Set line colour and width.\n\t\t\tthis.ctx.strokeStyle = this.pointerGuide.strokeStyle\n\t\t\tthis.ctx.lineWidth = this.pointerGuide.lineWidth\n\n\t\t\t// Draw from the center of the wheel outwards past the wheel outer radius.\n\t\t\tthis.ctx.beginPath()\n\t\t\tthis.ctx.moveTo(this.centerX, this.centerY)\n\t\t\tthis.ctx.lineTo(this.centerX, -(this.outerRadius / 4))\n\n\t\t\tthis.ctx.stroke()\n\t\t\tthis.ctx.restore()\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function takes an image such as PNG and draws it on the canvas making its center at the centerX and center for the wheel.\n\t// ====================================================================================================================\n\tdrawWheelImage() {\n\t\t// Double check the wheelImage property of this class is not null. This does not actually detect that an image\n\t\t// source was set and actually loaded so might get error if this is not the case. This is why the initial call\n\t\t// to draw() should be done from a wheelImage.onload callback as detailed in example documentation.\n\t\tif (this.wheelImage != null) {\n\t\t\t// Work out the correct X and Y to draw the image at. We need to get the center point of the image\n\t\t\t// aligned over the center point of the wheel, we can't just place it at 0, 0.\n\t\t\tvar imageLeft = this.centerX - this.wheelImage.height / 2\n\t\t\tvar imageTop = this.centerY - this.wheelImage.width / 2\n\n\t\t\t// Rotate and then draw the wheel.\n\t\t\t// We must rotate by the rotationAngle before drawing to ensure that image wheels will spin.\n\t\t\tthis.ctx.save()\n\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\tthis.ctx.rotate(this.degToRad(this.rotationAngle))\n\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\tthis.ctx.drawImage(this.wheelImage, imageLeft, imageTop)\n\n\t\t\tthis.ctx.restore()\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function draws the wheel on the canvas by rendering the image for each segment.\n\t// ====================================================================================================================\n\tdrawSegmentImages() {\n\t\t// Again check have context in case this function was called directly and not via draw function.\n\t\tif (this.ctx) {\n\t\t\t// Draw the segments if there is at least one in the segments array.\n\t\t\tif (this.segments) {\n\t\t\t\t// Loop though and output all segments - position 0 of the array is not used, so start loop from index 1\n\t\t\t\t// this is to avoid confusion when talking about the first segment.\n\t\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t\t\t// Get the segment object as we need it to read options from.\n\t\t\t\t\tvar seg = this.segments[x]\n\n\t\t\t\t\t// Check image has loaded so a property such as height has a value.\n\t\t\t\t\tif (seg.imgData.height) {\n\t\t\t\t\t\t// Work out the correct X and Y to draw the image at which depends on the direction of the image.\n\t\t\t\t\t\t// Images can be created in 4 directions. North, South, East, West.\n\t\t\t\t\t\t// North: Outside at top, inside at bottom. Sits evenly over the 0 degrees angle.\n\t\t\t\t\t\t// South: Outside at bottom, inside at top. Sits evenly over the 180 degrees angle.\n\t\t\t\t\t\t// East: Outside at right, inside at left. Sits evenly over the 90 degrees angle.\n\t\t\t\t\t\t// West: Outside at left, inside at right. Sits evenly over the 270 degrees angle.\n\t\t\t\t\t\tvar imageLeft = 0\n\t\t\t\t\t\tvar imageTop = 0\n\t\t\t\t\t\tvar imageAngle = 0\n\t\t\t\t\t\tvar imageDirection = ''\n\n\t\t\t\t\t\tif (seg.imageDirection !== null) imageDirection = seg.imageDirection\n\t\t\t\t\t\telse imageDirection = this.imageDirection\n\n\t\t\t\t\t\tif (imageDirection == 'S') {\n\t\t\t\t\t\t\t// Left set so image sits half/half over the 180 degrees point.\n\t\t\t\t\t\t\timageLeft = this.centerX - seg.imgData.width / 2\n\n\t\t\t\t\t\t\t// Top so image starts at the centerY.\n\t\t\t\t\t\t\timageTop = this.centerY\n\n\t\t\t\t\t\t\t// Angle to draw the image is its starting angle + half its size.\n\t\t\t\t\t\t\t// Here we add 180 to the angle to the segment is poistioned correctly.\n\t\t\t\t\t\t\timageAngle = seg.startAngle + 180 + (seg.endAngle - seg.startAngle) / 2\n\t\t\t\t\t\t} else if (imageDirection == 'E') {\n\t\t\t\t\t\t\t// Left set so image starts and the center point.\n\t\t\t\t\t\t\timageLeft = this.centerX\n\n\t\t\t\t\t\t\t// Top is so that it sits half/half over the 90 degree point.\n\t\t\t\t\t\t\timageTop = this.centerY - seg.imgData.height / 2\n\n\t\t\t\t\t\t\t// Again get the angle in the center of the segment and add it to the rotation angle.\n\t\t\t\t\t\t\t// this time we need to add 270 to that to the segment is rendered the correct place.\n\t\t\t\t\t\t\timageAngle = seg.startAngle + 270 + (seg.endAngle - seg.startAngle) / 2\n\t\t\t\t\t\t} else if (imageDirection == 'W') {\n\t\t\t\t\t\t\t// Left is the centerX minus the width of the image.\n\t\t\t\t\t\t\timageLeft = this.centerX - seg.imgData.width\n\n\t\t\t\t\t\t\t// Top is so that it sits half/half over the 270 degree point.\n\t\t\t\t\t\t\timageTop = this.centerY - seg.imgData.height / 2\n\n\t\t\t\t\t\t\t// Again get the angle in the center of the segment and add it to the rotation angle.\n\t\t\t\t\t\t\t// this time we need to add 90 to that to the segment is rendered the correct place.\n\t\t\t\t\t\t\timageAngle = seg.startAngle + 90 + (seg.endAngle - seg.startAngle) / 2\n\t\t\t\t\t\t} // North is the default.\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// Left set so image sits half/half over the 0 degrees point.\n\t\t\t\t\t\t\timageLeft = this.centerX - seg.imgData.width / 2\n\n\t\t\t\t\t\t\t// Top so image is its height out (above) the center point.\n\t\t\t\t\t\t\timageTop = this.centerY - seg.imgData.height\n\n\t\t\t\t\t\t\t// Angle to draw the image is its starting angle + half its size.\n\t\t\t\t\t\t\t// this sits it half/half over the center angle of the segment.\n\t\t\t\t\t\t\timageAngle = seg.startAngle + (seg.endAngle - seg.startAngle) / 2\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// --------------------------------------------------\n\t\t\t\t\t\t// Rotate to the position of the segment and then draw the image.\n\t\t\t\t\t\tthis.ctx.save()\n\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\n\t\t\t\t\t\t// So math here is the rotation angle of the wheel plus half way between the start and end angle of the segment.\n\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(this.rotationAngle + imageAngle))\n\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t// Draw the image.\n\t\t\t\t\t\tthis.ctx.drawImage(seg.imgData, imageLeft, imageTop)\n\n\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log('Segment ' + x + ' imgData is not loaded')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function draws the wheel on the page by rendering the segments on the canvas.\n\t// ====================================================================================================================\n\tdrawSegments() {\n\t\t// Again check have context in case this function was called directly and not via draw function.\n\t\tif (this.ctx) {\n\t\t\t// Draw the segments if there is at least one in the segments array.\n\t\t\tif (this.segments) {\n\t\t\t\t// Loop though and output all segments - position 0 of the array is not used, so start loop from index 1\n\t\t\t\t// this is to avoid confusion when talking about the first segment.\n\t\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t\t\t// Get the segment object as we need it to read options from.\n\t\t\t\t\tvar seg = this.segments[x]\n\n\t\t\t\t\tvar fillStyle\n\t\t\t\t\tvar lineWidth\n\t\t\t\t\tvar strokeStyle\n\n\t\t\t\t\t// Set the variables that defined in the segment, or use the default options.\n\t\t\t\t\tif (seg.fillStyle !== null) fillStyle = seg.fillStyle\n\t\t\t\t\telse fillStyle = this.fillStyle\n\n\t\t\t\t\tthis.ctx.fillStyle = fillStyle\n\n\t\t\t\t\tif (seg.lineWidth !== null) lineWidth = seg.lineWidth\n\t\t\t\t\telse lineWidth = this.lineWidth\n\n\t\t\t\t\tthis.ctx.lineWidth = lineWidth\n\n\t\t\t\t\tif (seg.strokeStyle !== null) strokeStyle = seg.strokeStyle\n\t\t\t\t\telse strokeStyle = this.strokeStyle\n\n\t\t\t\t\tthis.ctx.strokeStyle = strokeStyle\n\n\t\t\t\t\t// Check there is a strokeStyle or fillStyle, if either the the segment is invisible so should not\n\t\t\t\t\t// try to draw it otherwise a path is began but not ended.\n\t\t\t\t\tif (strokeStyle || fillStyle) {\n\t\t\t\t\t\t// ----------------------------------\n\t\t\t\t\t\t// Begin a path as the segment consists of an arc and 2 lines.\n\t\t\t\t\t\tthis.ctx.beginPath()\n\n\t\t\t\t\t\t// If don't have an inner radius then move to the center of the wheel as we want a line out from the center\n\t\t\t\t\t\t// to the start of the arc for the outside of the wheel when we arc. Canvas will draw the connecting line for us.\n\t\t\t\t\t\tif (!this.innerRadius) {\n\t\t\t\t\t\t\tthis.ctx.moveTo(this.centerX, this.centerY)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//++ do need to draw the starting line in the correct x + y based on the start angle\n\t\t\t\t\t\t\t//++ otherwise as seen when the wheel does not use up 360 the starting segment is missing the stroked side,\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Draw the outer arc of the segment clockwise in direction -->\n\t\t\t\t\t\tthis.ctx.arc(\n\t\t\t\t\t\t\tthis.centerX,\n\t\t\t\t\t\t\tthis.centerY,\n\t\t\t\t\t\t\tthis.outerRadius,\n\t\t\t\t\t\t\tthis.degToRad(seg.startAngle + this.rotationAngle - 90),\n\t\t\t\t\t\t\tthis.degToRad(seg.endAngle + this.rotationAngle - 90),\n\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tif (this.innerRadius) {\n\t\t\t\t\t\t\t// Draw another arc, this time anticlockwise <-- at the innerRadius between the end angle and the start angle.\n\t\t\t\t\t\t\t// Canvas will draw a connecting line from the end of the outer arc to the beginning of the inner arc completing the shape.\n\n\t\t\t\t\t\t\t//++ Think the reason the lines are thinner for 2 of the segments is because the thing auto chops part of it\n\t\t\t\t\t\t\t//++ when doing the next one. Again think that actually drawing the lines will help.\n\n\t\t\t\t\t\t\tthis.ctx.arc(\n\t\t\t\t\t\t\t\tthis.centerX,\n\t\t\t\t\t\t\t\tthis.centerY,\n\t\t\t\t\t\t\t\tthis.innerRadius,\n\t\t\t\t\t\t\t\tthis.degToRad(seg.endAngle + this.rotationAngle - 90),\n\t\t\t\t\t\t\t\tthis.degToRad(seg.startAngle + this.rotationAngle - 90),\n\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// If no inner radius then we draw a line back to the center of the wheel.\n\t\t\t\t\t\t\tthis.ctx.lineTo(this.centerX, this.centerY)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Fill and stroke the segment. Only do either if a style was specified, if the style is null then\n\t\t\t\t\t\t// we assume the developer did not want that particular thing.\n\t\t\t\t\t\t// For example no stroke style so no lines to be drawn.\n\t\t\t\t\t\tif (fillStyle) this.ctx.fill()\n\n\t\t\t\t\t\tif (strokeStyle) this.ctx.stroke()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This draws the text on the segments using the specified text options.\n\t// ====================================================================================================================\n\tdrawSegmentText() {\n\t\t// Again only draw the text if have a canvas context.\n\t\tif (this.ctx) {\n\t\t\t// Declare variables to hold the values. These are populated either with the value for the specific segment,\n\t\t\t// or if not specified then the global default value.\n\t\t\tvar fontFamily\n\t\t\tvar fontSize\n\t\t\tvar fontWeight\n\t\t\tvar orientation\n\t\t\tvar alignment\n\t\t\tvar direction\n\t\t\tvar margin\n\t\t\tvar fillStyle\n\t\t\tvar strokeStyle\n\t\t\tvar lineWidth\n\t\t\tvar fontSetting\n\n\t\t\t// Loop though all the segments.\n\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t\t// Save the context so it is certain that each segment text option will not affect the other.\n\t\t\t\tthis.ctx.save()\n\n\t\t\t\t// Get the segment object as we need it to read options from.\n\t\t\t\tvar seg = this.segments[x]\n\n\t\t\t\t// Check is text as no point trying to draw if there is no text to render.\n\t\t\t\tif (seg.text) {\n\t\t\t\t\t// Set values to those for the specific segment or use global default if null.\n\t\t\t\t\tif (seg.textFontFamily !== null) fontFamily = seg.textFontFamily\n\t\t\t\t\telse fontFamily = this.textFontFamily\n\t\t\t\t\tif (seg.textFontSize !== null) fontSize = seg.textFontSize\n\t\t\t\t\telse fontSize = this.textFontSize\n\t\t\t\t\tif (seg.textFontWeight !== null) fontWeight = seg.textFontWeight\n\t\t\t\t\telse fontWeight = this.textFontWeight\n\t\t\t\t\tif (seg.textOrientation !== null) orientation = seg.textOrientation\n\t\t\t\t\telse orientation = this.textOrientation\n\t\t\t\t\tif (seg.textAlignment !== null) alignment = seg.textAlignment\n\t\t\t\t\telse alignment = this.textAlignment\n\t\t\t\t\tif (seg.textDirection !== null) direction = seg.textDirection\n\t\t\t\t\telse direction = this.textDirection\n\t\t\t\t\tif (seg.textMargin !== null) margin = seg.textMargin\n\t\t\t\t\telse margin = this.textMargin\n\t\t\t\t\tif (seg.textFillStyle !== null) fillStyle = seg.textFillStyle\n\t\t\t\t\telse fillStyle = this.textFillStyle\n\t\t\t\t\tif (seg.textStrokeStyle !== null) strokeStyle = seg.textStrokeStyle\n\t\t\t\t\telse strokeStyle = this.textStrokeStyle\n\t\t\t\t\tif (seg.textLineWidth !== null) lineWidth = seg.textLineWidth\n\t\t\t\t\telse lineWidth = this.textLineWidth\n\n\t\t\t\t\t// ------------------------------\n\t\t\t\t\t// We need to put the font bits together in to one string.\n\t\t\t\t\tfontSetting = ''\n\n\t\t\t\t\tif (fontWeight != null) fontSetting += fontWeight + ' '\n\n\t\t\t\t\tif (fontSize != null) fontSetting += fontSize + 'px ' // Fonts on canvas are always a px value.\n\n\t\t\t\t\tif (fontFamily != null) fontSetting += fontFamily\n\n\t\t\t\t\t// Now set the canvas context to the decided values.\n\t\t\t\t\tthis.ctx.font = fontSetting\n\t\t\t\t\tthis.ctx.fillStyle = fillStyle\n\t\t\t\t\tthis.ctx.strokeStyle = strokeStyle\n\t\t\t\t\tthis.ctx.lineWidth = lineWidth\n\n\t\t\t\t\t// Split the text in to multiple lines on the \\n character.\n\t\t\t\t\tvar lines = seg.text.split('\\n')\n\n\t\t\t\t\t// Figure out the starting offset for the lines as when there are multiple lines need to center the text\n\t\t\t\t\t// vertically in the segment (when thinking of normal horozontal text).\n\t\t\t\t\tvar lineOffset = 0 - fontSize * (lines.length / 2) + fontSize / 2\n\n\t\t\t\t\t// The offset works great for horozontal and vertial text, also centered curved. But when the text is curved\n\t\t\t\t\t// and the alignment is outer then the multiline text should not have some text outside the wheel. Same if inner curved.\n\t\t\t\t\tif (orientation == 'curved' && (alignment == 'inner' || alignment == 'outer')) {\n\t\t\t\t\t\tlineOffset = 0\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\t\t\t\t// ---------------------------------\n\t\t\t\t\t\t// If direction is reversed then do things differently than if normal (which is the default - see further down)\n\t\t\t\t\t\tif (direction == 'reversed') {\n\t\t\t\t\t\t\t// When drawing reversed or 'upside down' we need to do some trickery on our part.\n\t\t\t\t\t\t\t// The canvas text rendering function still draws the text left to right and the correct way up,\n\t\t\t\t\t\t\t// so we need to overcome this with rotating the opposite side of the wheel the correct way up then pulling the text\n\t\t\t\t\t\t\t// through the center point to the correct segment it is supposed to be on.\n\t\t\t\t\t\t\tif (orientation == 'horizontal') {\n\t\t\t\t\t\t\t\tif (alignment == 'inner') this.ctx.textAlign = 'right'\n\t\t\t\t\t\t\t\telse if (alignment == 'outer') this.ctx.textAlign = 'left'\n\t\t\t\t\t\t\t\telse this.ctx.textAlign = 'center'\n\n\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'middle'\n\n\t\t\t\t\t\t\t\t// Work out the angle to rotate the wheel, this is in the center of the segment but on the opposite side of the wheel which is why do -180.\n\t\t\t\t\t\t\t\tvar textAngle = this.degToRad(\n\t\t\t\t\t\t\t\t\tseg.endAngle - (seg.endAngle - seg.startAngle) / 2 + this.rotationAngle - 90 - 180\n\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\tthis.ctx.save()\n\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\tthis.ctx.rotate(textAngle)\n\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\tif (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// In reversed state the margin is subtracted from the innerX.\n\t\t\t\t\t\t\t\t\t// When inner the inner radius also comes in to play.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX - this.innerRadius - margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX - this.innerRadius - margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} else if (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// In reversed state the position is the center minus the radius + the margin for outer aligned text.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX - this.outerRadius + margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX - this.outerRadius + margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// In reversed state the everything in minused.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX -\n\t\t\t\t\t\t\t\t\t\t\t\tthis.innerRadius -\n\t\t\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 -\n\t\t\t\t\t\t\t\t\t\t\t\tmargin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX -\n\t\t\t\t\t\t\t\t\t\t\t\tthis.innerRadius -\n\t\t\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 -\n\t\t\t\t\t\t\t\t\t\t\t\tmargin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t} else if (orientation == 'vertical') {\n\t\t\t\t\t\t\t\t// See normal code further down for comments on how it works, this is similar by plus/minus is reversed.\n\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'center'\n\n\t\t\t\t\t\t\t\t// In reversed mode this are reversed.\n\t\t\t\t\t\t\t\tif (alignment == 'inner') this.ctx.textBaseline = 'top'\n\t\t\t\t\t\t\t\telse if (alignment == 'outer') this.ctx.textBaseline = 'bottom'\n\t\t\t\t\t\t\t\telse this.ctx.textBaseline = 'middle'\n\n\t\t\t\t\t\t\t\tvar textAngle = seg.endAngle - (seg.endAngle - seg.startAngle) / 2 - 180\n\t\t\t\t\t\t\t\ttextAngle += this.rotationAngle\n\n\t\t\t\t\t\t\t\tthis.ctx.save()\n\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(textAngle))\n\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\tif (alignment == 'outer') var yPos = this.centerY + this.outerRadius - margin\n\t\t\t\t\t\t\t\telse if (alignment == 'inner') var yPos = this.centerY + this.innerRadius + margin\n\n\t\t\t\t\t\t\t\t// I have found that the text looks best when a fraction of the font size is shaved off.\n\t\t\t\t\t\t\t\tvar yInc = fontSize - fontSize / 9\n\n\t\t\t\t\t\t\t\t// Loop though and output the characters.\n\t\t\t\t\t\t\t\tif (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// In reversed mode outer means text in 6 o'clock segment sits at bottom of the wheel and we draw up.\n\t\t\t\t\t\t\t\t\tfor (var c = lines[i].length - 1; c >= 0; c--) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos -= yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// In reversed mode inner text is drawn from top of segment at 6 o'clock position to bottom of the wheel.\n\t\t\t\t\t\t\t\t\tfor (var c = 0; c < lines[i].length; c++) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos += yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (alignment == 'center') {\n\t\t\t\t\t\t\t\t\t// Again for reversed this is the opposite of before.\n\t\t\t\t\t\t\t\t\t// If there is more than one character in the text then an adjustment to the position needs to be done.\n\t\t\t\t\t\t\t\t\t// What we are aiming for is to position the center of the text at the center point between the inner and outer radius.\n\t\t\t\t\t\t\t\t\tvar centerAdjustment = 0\n\n\t\t\t\t\t\t\t\t\tif (lines[i].length > 1) {\n\t\t\t\t\t\t\t\t\t\tcenterAdjustment = (yInc * (lines[i].length - 1)) / 2\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar yPos =\n\t\t\t\t\t\t\t\t\t\tthis.centerY +\n\t\t\t\t\t\t\t\t\t\tthis.innerRadius +\n\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 +\n\t\t\t\t\t\t\t\t\t\tcenterAdjustment +\n\t\t\t\t\t\t\t\t\t\tmargin\n\n\t\t\t\t\t\t\t\t\tfor (var c = lines[i].length - 1; c >= 0; c--) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos -= yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t} else if (orientation == 'curved') {\n\t\t\t\t\t\t\t\t// There is no built in canvas function to draw text around an arc,\n\t\t\t\t\t\t\t\t// so we need to do this ourselves.\n\t\t\t\t\t\t\t\tvar radius = 0\n\n\t\t\t\t\t\t\t\t// Set the alignment of the text - inner, outer, or center by calculating\n\t\t\t\t\t\t\t\t// how far out from the center point of the wheel the text is drawn.\n\t\t\t\t\t\t\t\tif (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// When alignment is inner the radius is the innerRadius plus any margin.\n\t\t\t\t\t\t\t\t\tradius = this.innerRadius + margin\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'top'\n\t\t\t\t\t\t\t\t} else if (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// Outer it is the outerRadius minus any margin.\n\t\t\t\t\t\t\t\t\tradius = this.outerRadius - margin\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'bottom'\n\n\t\t\t\t\t\t\t\t\t// We need to adjust the radius in this case to take in to multiline text.\n\t\t\t\t\t\t\t\t\t// In this case the radius needs to be further out, not at the inner radius.\n\t\t\t\t\t\t\t\t\tradius -= fontSize * (lines.length - 1)\n\t\t\t\t\t\t\t\t} else if (alignment == 'center') {\n\t\t\t\t\t\t\t\t\t// When center we want the text halfway between the inner and outer radius.\n\t\t\t\t\t\t\t\t\tradius = this.innerRadius + margin + (this.outerRadius - this.innerRadius) / 2\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'middle'\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Set the angle to increment by when looping though and outputting the characters in the text\n\t\t\t\t\t\t\t\t// as we do this by rotating the wheel small amounts adding each character.\n\t\t\t\t\t\t\t\tvar anglePerChar = 0\n\t\t\t\t\t\t\t\tvar drawAngle = 0\n\n\t\t\t\t\t\t\t\t// If more than one character in the text then...\n\t\t\t\t\t\t\t\tif (lines[i].length > 1) {\n\t\t\t\t\t\t\t\t\t// Text is drawn from the left.\n\t\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'left'\n\n\t\t\t\t\t\t\t\t\t// Work out how much angle the text rendering loop below needs to rotate by for each character to render them next to each other.\n\t\t\t\t\t\t\t\t\t// I have discovered that 4 * the font size / 10 at 100px radius is the correct spacing for between the characters\n\t\t\t\t\t\t\t\t\t// using a monospace font, non monospace may look a little odd as in there will appear to be extra spaces between chars.\n\t\t\t\t\t\t\t\t\tanglePerChar = 4 * (fontSize / 10)\n\n\t\t\t\t\t\t\t\t\t// Work out what percentage the radius the text will be drawn at is of 100px.\n\t\t\t\t\t\t\t\t\tradiusPercent = 100 / radius\n\n\t\t\t\t\t\t\t\t\t// Then use this to scale up or down the anglePerChar value.\n\t\t\t\t\t\t\t\t\t// When the radius is less than 100px we need more angle between the letters, when radius is greater (so the text is further\n\t\t\t\t\t\t\t\t\t// away from the center of the wheel) the angle needs to be less otherwise the characters will appear further apart.\n\t\t\t\t\t\t\t\t\tanglePerChar = anglePerChar * radiusPercent\n\n\t\t\t\t\t\t\t\t\t// Next we want the text to be drawn in the middle of the segment, without this it would start at the beginning of the segment.\n\t\t\t\t\t\t\t\t\t// To do this we need to work out how much arc the text will take up in total then subtract half of this from the center\n\t\t\t\t\t\t\t\t\t// of the segment so that it sits centred.\n\t\t\t\t\t\t\t\t\ttotalArc = anglePerChar * lines[i].length\n\n\t\t\t\t\t\t\t\t\t// Now set initial draw angle to half way between the start and end of the segment.\n\t\t\t\t\t\t\t\t\tdrawAngle = seg.startAngle + ((seg.endAngle - seg.startAngle) / 2 - totalArc / 2)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// The initial draw angle is the center of the segment when only one character.\n\t\t\t\t\t\t\t\t\tdrawAngle = seg.startAngle + (seg.endAngle - seg.startAngle) / 2\n\n\t\t\t\t\t\t\t\t\t// To ensure is dead-center the text alignment also needs to be centered.\n\t\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'center'\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// ----------------------\n\t\t\t\t\t\t\t\t// Adjust the initial draw angle as needed to take in to account the rotationAngle of the wheel.\n\t\t\t\t\t\t\t\tdrawAngle += this.rotationAngle\n\n\t\t\t\t\t\t\t\t// And as with other 'reverse' text direction functions we need to subtract 180 degrees from the angle\n\t\t\t\t\t\t\t\t// because when it comes to draw the characters in the loop below we add the radius instead of subtract it.\n\t\t\t\t\t\t\t\tdrawAngle -= 180\n\n\t\t\t\t\t\t\t\t// ----------------------\n\t\t\t\t\t\t\t\t// Now the drawing itself.\n\t\t\t\t\t\t\t\t// In reversed direction mode we loop through the characters in the text backwards in order for them to appear on screen correctly\n\t\t\t\t\t\t\t\tfor (c = lines[i].length; c >= 0; c--) {\n\t\t\t\t\t\t\t\t\tthis.ctx.save()\n\n\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t// Rotate the wheel to the draw angle as we need to add the character at this location.\n\t\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(drawAngle))\n\t\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\t\t// Now draw the character directly below the center point of the wheel at the appropriate radius.\n\t\t\t\t\t\t\t\t\t// Note in the reversed mode we add the radius to the this.centerY instead of subtract.\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(character, this.centerX, this.centerY + radius + lineOffset)\n\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(character, this.centerX, this.centerY + radius + lineOffset)\n\n\t\t\t\t\t\t\t\t\t// Increment the drawAngle by the angle per character so next loop we rotate\n\t\t\t\t\t\t\t\t\t// to the next angle required to draw the character at.\n\t\t\t\t\t\t\t\t\tdrawAngle += anglePerChar\n\n\t\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Normal direction so do things normally.\n\t\t\t\t\t\t\t// Check text orientation, of horizontal then reasonably straight forward, if vertical then a bit more work to do.\n\t\t\t\t\t\t\tif (orientation == 'horizontal') {\n\t\t\t\t\t\t\t\t// Based on the text alignment, set the correct value in the context.\n\t\t\t\t\t\t\t\tif (alignment == 'inner') this.ctx.textAlign = 'left'\n\t\t\t\t\t\t\t\telse if (alignment == 'outer') this.ctx.textAlign = 'right'\n\t\t\t\t\t\t\t\telse this.ctx.textAlign = 'center'\n\n\t\t\t\t\t\t\t\t// Set this too.\n\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'middle'\n\n\t\t\t\t\t\t\t\t// Work out the angle around the wheel to draw the text at, which is simply in the middle of the segment the text is for.\n\t\t\t\t\t\t\t\t// The rotation angle is added in to correct the annoyance with the canvas arc drawing functions which put the 0 degrees at the 3 oclock\n\t\t\t\t\t\t\t\tvar textAngle = this.degToRad(\n\t\t\t\t\t\t\t\t\tseg.endAngle - (seg.endAngle - seg.startAngle) / 2 + this.rotationAngle - 90\n\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t// We need to rotate in order to draw the text because it is output horizontally, so to\n\t\t\t\t\t\t\t\t// place correctly around the wheel for all but a segment at 3 o'clock we need to rotate.\n\t\t\t\t\t\t\t\tthis.ctx.save()\n\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\tthis.ctx.rotate(textAngle)\n\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\t// --------------------------\n\t\t\t\t\t\t\t\t// Draw the text based on its alignment adding margin if inner or outer.\n\t\t\t\t\t\t\t\tif (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// Inner means that the text is aligned with the inner of the wheel. If looking at a segment in in the 3 o'clock position\n\t\t\t\t\t\t\t\t\t// it would look like the text is left aligned within the segment.\n\n\t\t\t\t\t\t\t\t\t// Because the segments are smaller towards the inner of the wheel, in order for the text to fit is is a good idea that\n\t\t\t\t\t\t\t\t\t// a margin is added which pushes the text towards the outer a bit.\n\n\t\t\t\t\t\t\t\t\t// The inner radius also needs to be taken in to account as when inner aligned.\n\n\t\t\t\t\t\t\t\t\t// If fillstyle is set the draw the text filled in.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX + this.innerRadius + margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t// If stroke style is set draw the text outline.\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX + this.innerRadius + margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} else if (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// Outer means the text is aligned with the outside of the wheel, so if looking at a segment in the 3 o'clock position\n\t\t\t\t\t\t\t\t\t// it would appear the text is right aligned. To position we add the radius of the wheel in to the equation\n\t\t\t\t\t\t\t\t\t// and subtract the margin this time, rather than add it.\n\n\t\t\t\t\t\t\t\t\t// I don't understand why, but in order of the text to render correctly with stroke and fill, the stroke needs to\n\t\t\t\t\t\t\t\t\t// come first when drawing outer, rather than second when doing inner.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX + this.outerRadius - margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t// If fillstyle the fill the text.\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX + this.outerRadius - margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// In this case the text is to drawn centred in the segment.\n\t\t\t\t\t\t\t\t\t// Typically no margin is required, however even though centred the text can look closer to the inner of the wheel\n\t\t\t\t\t\t\t\t\t// due to the way the segments narrow in (is optical effect), so if a margin is specified it is placed on the inner\n\t\t\t\t\t\t\t\t\t// side so the text is pushed towards the outer.\n\n\t\t\t\t\t\t\t\t\t// If stoke style the stroke the text.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX +\n\t\t\t\t\t\t\t\t\t\t\t\tthis.innerRadius +\n\t\t\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 +\n\t\t\t\t\t\t\t\t\t\t\t\tmargin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t// If fillstyle the fill the text.\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX +\n\t\t\t\t\t\t\t\t\t\t\t\tthis.innerRadius +\n\t\t\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 +\n\t\t\t\t\t\t\t\t\t\t\t\tmargin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Restore the context so that wheel is returned to original position.\n\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t} else if (orientation == 'vertical') {\n\t\t\t\t\t\t\t\t// If vertical then we need to do this ourselves because as far as I am aware there is no option built in to html canvas\n\t\t\t\t\t\t\t\t// which causes the text to draw downwards or upwards one character after another.\n\n\t\t\t\t\t\t\t\t// In this case the textAlign is always center, but the baseline is either top or bottom\n\t\t\t\t\t\t\t\t// depending on if inner or outer alignment has been specified.\n\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'center'\n\n\t\t\t\t\t\t\t\tif (alignment == 'inner') this.ctx.textBaseline = 'bottom'\n\t\t\t\t\t\t\t\telse if (alignment == 'outer') this.ctx.textBaseline = 'top'\n\t\t\t\t\t\t\t\telse this.ctx.textBaseline = 'middle'\n\n\t\t\t\t\t\t\t\t// The angle to draw the text at is halfway between the end and the starting angle of the segment.\n\t\t\t\t\t\t\t\tvar textAngle = seg.endAngle - (seg.endAngle - seg.startAngle) / 2\n\n\t\t\t\t\t\t\t\t// Ensure the rotation angle of the wheel is added in, otherwise the test placement won't match\n\t\t\t\t\t\t\t\t// the segments they are supposed to be for.\n\t\t\t\t\t\t\t\ttextAngle += this.rotationAngle\n\n\t\t\t\t\t\t\t\t// Rotate so can begin to place the text.\n\t\t\t\t\t\t\t\tthis.ctx.save()\n\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(textAngle))\n\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\t// Work out the position to start drawing in based on the alignment.\n\t\t\t\t\t\t\t\t// If outer then when considering a segment at the 12 o'clock position want to start drawing down from the top of the wheel.\n\t\t\t\t\t\t\t\tif (alignment == 'outer') var yPos = this.centerY - this.outerRadius + margin\n\t\t\t\t\t\t\t\telse if (alignment == 'inner') var yPos = this.centerY - this.innerRadius - margin\n\n\t\t\t\t\t\t\t\t// We need to know how much to move the y axis each time.\n\t\t\t\t\t\t\t\t// This is not quite simply the font size as that puts a larger gap in between the letters\n\t\t\t\t\t\t\t\t// than expected, especially with monospace fonts. I found that shaving a little off makes it look \"right\".\n\t\t\t\t\t\t\t\tvar yInc = fontSize - fontSize / 9\n\n\t\t\t\t\t\t\t\t// Loop though and output the characters.\n\t\t\t\t\t\t\t\tif (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// For this alignment we draw down from the top of a segment at the 12 o'clock position to simply\n\t\t\t\t\t\t\t\t\t// loop though the characters in order.\n\t\t\t\t\t\t\t\t\tfor (var c = 0; c < lines[i].length; c++) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos += yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// Here we draw from the inner of the wheel up, but in order for the letters in the text text to\n\t\t\t\t\t\t\t\t\t// remain in the correct order when reading, we actually need to loop though the text characters backwards.\n\t\t\t\t\t\t\t\t\tfor (var c = lines[i].length - 1; c >= 0; c--) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos -= yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (alignment == 'center') {\n\t\t\t\t\t\t\t\t\t// This is the most complex of the three as we need to draw the text top down centred between the inner and outer of the wheel.\n\t\t\t\t\t\t\t\t\t// So logically we have to put the middle character of the text in the center then put the others each side of it.\n\t\t\t\t\t\t\t\t\t// In reality that is a really bad way to do it, we can achieve the same if not better positioning using a\n\t\t\t\t\t\t\t\t\t// variation on the method used for the rendering of outer aligned text once we have figured out the height of the text.\n\n\t\t\t\t\t\t\t\t\t// If there is more than one character in the text then an adjustment to the position needs to be done.\n\t\t\t\t\t\t\t\t\t// What we are aiming for is to position the center of the text at the center point between the inner and outer radius.\n\t\t\t\t\t\t\t\t\tvar centerAdjustment = 0\n\n\t\t\t\t\t\t\t\t\tif (lines[i].length > 1) {\n\t\t\t\t\t\t\t\t\t\tcenterAdjustment = (yInc * (lines[i].length - 1)) / 2\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Now work out where to start rendering the string. This is half way between the inner and outer of the wheel, with the\n\t\t\t\t\t\t\t\t\t// centerAdjustment included to correctly position texts with more than one character over the center.\n\t\t\t\t\t\t\t\t\t// If there is a margin it is used to push the text away from the center of the wheel.\n\t\t\t\t\t\t\t\t\tvar yPos =\n\t\t\t\t\t\t\t\t\t\tthis.centerY -\n\t\t\t\t\t\t\t\t\t\tthis.innerRadius -\n\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 -\n\t\t\t\t\t\t\t\t\t\tcenterAdjustment -\n\t\t\t\t\t\t\t\t\t\tmargin\n\n\t\t\t\t\t\t\t\t\t// Now loop and draw just like outer text rendering.\n\t\t\t\t\t\t\t\t\tfor (var c = 0; c < lines[i].length; c++) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos += yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t} else if (orientation == 'curved') {\n\t\t\t\t\t\t\t\t// There is no built in canvas function to draw text around an arc, so\n\t\t\t\t\t\t\t\t// we need to do this ourselves.\n\t\t\t\t\t\t\t\tvar radius = 0\n\n\t\t\t\t\t\t\t\t// Set the alignment of the text - inner, outer, or center by calculating\n\t\t\t\t\t\t\t\t// how far out from the center point of the wheel the text is drawn.\n\t\t\t\t\t\t\t\tif (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// When alignment is inner the radius is the innerRadius plus any margin.\n\t\t\t\t\t\t\t\t\tradius = this.innerRadius + margin\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'bottom'\n\n\t\t\t\t\t\t\t\t\t// We need to adjust the radius in this case to take in to multiline text.\n\t\t\t\t\t\t\t\t\t// In this case the radius needs to be further out, not at the inner radius.\n\t\t\t\t\t\t\t\t\tradius += fontSize * (lines.length - 1)\n\t\t\t\t\t\t\t\t} else if (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// Outer it is the outerRadius minus any margin.\n\t\t\t\t\t\t\t\t\tradius = this.outerRadius - margin\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'top'\n\t\t\t\t\t\t\t\t} else if (alignment == 'center') {\n\t\t\t\t\t\t\t\t\t// When center we want the text halfway between the inner and outer radius.\n\t\t\t\t\t\t\t\t\tradius = this.innerRadius + margin + (this.outerRadius - this.innerRadius) / 2\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'middle'\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Set the angle to increment by when looping though and outputting the characters in the text\n\t\t\t\t\t\t\t\t// as we do this by rotating the wheel small amounts adding each character.\n\t\t\t\t\t\t\t\tvar anglePerChar = 0\n\t\t\t\t\t\t\t\tvar drawAngle = 0\n\n\t\t\t\t\t\t\t\t// If more than one character in the text then...\n\t\t\t\t\t\t\t\tif (lines[i].length > 1) {\n\t\t\t\t\t\t\t\t\t// Text is drawn from the left.\n\t\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'left'\n\n\t\t\t\t\t\t\t\t\t// Work out how much angle the text rendering loop below needs to rotate by for each character to render them next to each other.\n\t\t\t\t\t\t\t\t\t// I have discovered that 4 * the font size / 10 at 100px radius is the correct spacing for between the characters\n\t\t\t\t\t\t\t\t\t// using a monospace font, non monospace may look a little odd as in there will appear to be extra spaces between chars.\n\t\t\t\t\t\t\t\t\tanglePerChar = 4 * (fontSize / 10)\n\n\t\t\t\t\t\t\t\t\t// Work out what percentage the radius the text will be drawn at is of 100px.\n\t\t\t\t\t\t\t\t\tradiusPercent = 100 / radius\n\n\t\t\t\t\t\t\t\t\t// Then use this to scale up or down the anglePerChar value.\n\t\t\t\t\t\t\t\t\t// When the radius is less than 100px we need more angle between the letters, when radius is greater (so the text is further\n\t\t\t\t\t\t\t\t\t// away from the center of the wheel) the angle needs to be less otherwise the characters will appear further apart.\n\t\t\t\t\t\t\t\t\tanglePerChar = anglePerChar * radiusPercent\n\n\t\t\t\t\t\t\t\t\t// Next we want the text to be drawn in the middle of the segment, without this it would start at the beginning of the segment.\n\t\t\t\t\t\t\t\t\t// To do this we need to work out how much arc the text will take up in total then subtract half of this from the center\n\t\t\t\t\t\t\t\t\t// of the segment so that it sits centred.\n\t\t\t\t\t\t\t\t\ttotalArc = anglePerChar * lines[i].length\n\n\t\t\t\t\t\t\t\t\t// Now set initial draw angle to half way between the start and end of the segment.\n\t\t\t\t\t\t\t\t\tdrawAngle = seg.startAngle + ((seg.endAngle - seg.startAngle) / 2 - totalArc / 2)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// The initial draw angle is the center of the segment when only one character.\n\t\t\t\t\t\t\t\t\tdrawAngle = seg.startAngle + (seg.endAngle - seg.startAngle) / 2\n\n\t\t\t\t\t\t\t\t\t// To ensure is dead-center the text alignment also needs to be centred.\n\t\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'center'\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// ----------------------\n\t\t\t\t\t\t\t\t// Adjust the initial draw angle as needed to take in to account the rotationAngle of the wheel.\n\t\t\t\t\t\t\t\tdrawAngle += this.rotationAngle\n\n\t\t\t\t\t\t\t\t// ----------------------\n\t\t\t\t\t\t\t\t// Now the drawing itself.\n\t\t\t\t\t\t\t\t// Loop for each character in the text.\n\t\t\t\t\t\t\t\tfor (c = 0; c < lines[i].length; c++) {\n\t\t\t\t\t\t\t\t\tthis.ctx.save()\n\n\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t// Rotate the wheel to the draw angle as we need to add the character at this location.\n\t\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(drawAngle))\n\t\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\t\t// Now draw the character directly above the center point of the wheel at the appropriate radius.\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(character, this.centerX, this.centerY - radius + lineOffset)\n\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(character, this.centerX, this.centerY - radius + lineOffset)\n\n\t\t\t\t\t\t\t\t\t// Increment the drawAngle by the angle per character so next loop we rotate\n\t\t\t\t\t\t\t\t\t// to the next angle required to draw the character at.\n\t\t\t\t\t\t\t\t\tdrawAngle += anglePerChar\n\n\t\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Increment this ready for the next time.\n\t\t\t\t\t\tlineOffset += fontSize\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Restore so all text options are reset ready for the next text.\n\t\t\t\tthis.ctx.restore()\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// Converts degrees to radians which is what is used when specifying the angles on HTML5 canvas arcs.\n\t// ====================================================================================================================\n\tdegToRad(d) {\n\t\treturn d * 0.0174532925199432957\n\t}\n\n\t// ====================================================================================================================\n\t// This function sets the center location of the wheel, saves a function call to set x then y.\n\t// ====================================================================================================================\n\tsetCenter(x, y) {\n\t\tthis.centerX = x\n\t\tthis.centerY = y\n\t}\n\n\t// ====================================================================================================================\n\t// This function allows a segment to be added to the wheel. The position of the segment is optional,\n\t// if not specified the new segment will be added to the end of the wheel.\n\t// ====================================================================================================================\n\taddSegment(options, position) {\n\t\t// Create a new segment object passing the options in.\n\t\tnewSegment = new Segment(options)\n\n\t\t// Increment the numSegments property of the class since new segment being added.\n\t\tthis.numSegments++\n\t\tvar segmentPos\n\n\t\t// Work out where to place the segment, the default is simply as a new segment at the end of the wheel.\n\t\tif (typeof position !== 'undefined') {\n\t\t\t// Because we need to insert the segment at this position, not overwrite it, we need to move all segments after this\n\t\t\t// location along one in the segments array, before finally adding this new segment at the specified location.\n\t\t\tfor (var x = this.numSegments; x > position; x--) {\n\t\t\t\tthis.segments[x] = this.segments[x - 1]\n\t\t\t}\n\n\t\t\tthis.segments[position] = newSegment\n\t\t\tsegmentPos = position\n\t\t} else {\n\t\t\tthis.segments[this.numSegments] = newSegment\n\t\t\tsegmentPos = this.numSegments\n\t\t}\n\n\t\t// Since a segment has been added the segment sizes need to be re-computed so call function to do this.\n\t\tthis.updateSegmentSizes()\n\n\t\t// Return the segment object just created in the wheel (JavaScript will return it by reference), so that\n\t\t// further things can be done with it by the calling code if desired.\n\t\treturn this.segments[segmentPos]\n\t}\n\n\t// ====================================================================================================================\n\t// This function must be used if the canvasId is changed as we also need to get the context of the new canvas.\n\t// ====================================================================================================================\n\tsetCanvasId(canvasId) {\n\t\tif (canvasId) {\n\t\t\tthis.canvasId = canvasId\n\t\t\tthis.canvas = document.getElementById(this.canvasId)\n\n\t\t\tif (this.canvas) {\n\t\t\t\tthis.ctx = this.canvas.getContext('2d')\n\t\t\t}\n\t\t} else {\n\t\t\tthis.canvasId = null\n\t\t\tthis.ctx = null\n\t\t\tthis.canvas = null\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function deletes the specified segment from the wheel by removing it from the segments array.\n\t// It then sorts out the other bits such as update of the numSegments.\n\t// ====================================================================================================================\n\tdeleteSegment(position) {\n\t\t// There needs to be at least one segment in order for the wheel to draw, so only allow delete if there\n\t\t// is more than one segment currently left in the wheel.\n\n\t\t//++ check that specifying a position that does not exist - say 10 in a 6 segment wheel does not cause issues.\n\t\tif (this.numSegments > 1) {\n\t\t\t// If the position of the segment to remove has been specified.\n\t\t\tif (typeof position !== 'undefined') {\n\t\t\t\t// The array is to be shortened so we need to move all segments after the one\n\t\t\t\t// to be removed down one so there is no gap.\n\t\t\t\tfor (var x = position; x < this.numSegments; x++) {\n\t\t\t\t\tthis.segments[x] = this.segments[x + 1]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unset the last item in the segments array since there is now one less.\n\t\t\tthis.segments[this.numSegments] = undefined\n\n\t\t\t// Decrement the number of segments,\n\t\t\t// then call function to update the segment sizes.\n\t\t\tthis.numSegments--\n\t\t\tthis.updateSegmentSizes()\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function takes the x an the y of a mouse event, such as click or move, and converts the x and the y in to\n\t// co-ordinates on the canvas as the raw values are the x and the y from the top and left of the user's browser.\n\t// ====================================================================================================================\n\twindowToCanvas(x, y) {\n\t\tvar bbox = this.canvas.getBoundingClientRect()\n\n\t\treturn {\n\t\t\tx: Math.floor(x - bbox.left * (this.canvas.width / bbox.width)),\n\t\t\ty: Math.floor(y - bbox.top * (this.canvas.height / bbox.height)),\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function returns the segment object located at the specified x and y coordinates on the canvas.\n\t// It is used to allow things to be done with a segment clicked by the user, such as highlight, display or change some values, etc.\n\t// ====================================================================================================================\n\tgetSegmentAt(x, y) {\n\t\tvar foundSegment = null\n\n\t\t// Call function to return segment number.\n\t\tvar segmentNumber = this.getSegmentNumberAt(x, y)\n\n\t\t// If found one then set found segment to pointer to the segment object.\n\t\tif (segmentNumber !== null) {\n\t\t\tfoundSegment = this.segments[segmentNumber]\n\t\t}\n\n\t\treturn foundSegment\n\t}\n\n\t// ====================================================================================================================\n\t// Returns the number of the segment clicked instead of the segment object.\n\t// ====================================================================================================================\n\tgetSegmentNumberAt(x, y) {\n\t\t// KNOWN ISSUE: this does not work correct if the canvas is scaled using css, or has padding, border.\n\t\t// @TODO see if can find a solution at some point, check windowToCanvas working as needed, then below.\n\n\t\t// Call function above to convert the raw x and y from the user's browser to canvas coordinates\n\t\t// i.e. top and left is top and left of canvas, not top and left of the user's browser.\n\t\tvar loc = this.windowToCanvas(x, y)\n\n\t\t// ------------------------------------------\n\t\t// Now start the process of working out the segment clicked.\n\t\t// First we need to figure out the angle of an imaginary line between the centerX and centerY of the wheel and\n\t\t// the X and Y of the location (for example a mouse click).\n\t\tvar topBottom\n\t\tvar leftRight\n\t\tvar adjacentSideLength\n\t\tvar oppositeSideLength\n\t\tvar hypotenuseSideLength\n\n\t\t// We will use right triangle maths with the TAN function.\n\t\t// The start of the triangle is the wheel center, the adjacent side is along the x axis, and the opposite side is along the y axis.\n\n\t\t// We only ever use positive numbers to work out the triangle and the center of the wheel needs to be considered as 0 for the numbers\n\t\t// in the maths which is why there is the subtractions below. We also remember what quadrant of the wheel the location is in as we\n\t\t// need this information later to add 90, 180, 270 degrees to the angle worked out from the triangle to get the position around a 360 degree wheel.\n\t\tif (loc.x > this.centerX) {\n\t\t\tadjacentSideLength = loc.x - this.centerX\n\t\t\tleftRight = 'R' // Location is in the right half of the wheel.\n\t\t} else {\n\t\t\tadjacentSideLength = this.centerX - loc.x\n\t\t\tleftRight = 'L' // Location is in the left half of the wheel.\n\t\t}\n\n\t\tif (loc.y > this.centerY) {\n\t\t\toppositeSideLength = loc.y - this.centerY\n\t\t\ttopBottom = 'B' // Bottom half of wheel.\n\t\t} else {\n\t\t\toppositeSideLength = this.centerY - loc.y\n\t\t\ttopBottom = 'T' // Top Half of wheel.\n\t\t}\n\n\t\t// Now divide opposite by adjacent to get tan value.\n\t\tvar tanVal = oppositeSideLength / adjacentSideLength\n\n\t\t// Use the tan function and convert results to degrees since that is what we work with.\n\t\tvar result = (Math.atan(tanVal) * 180) / Math.PI\n\t\tvar locationAngle = 0\n\n\t\t// We also need the length of the hypotenuse as later on we need to compare this to the outerRadius of the segment / circle.\n\t\thypotenuseSideLength = Math.sqrt(\n\t\t\toppositeSideLength * oppositeSideLength + adjacentSideLength * adjacentSideLength\n\t\t)\n\n\t\t// ------------------------------------------\n\t\t// Now to make sense around the wheel we need to alter the values based on if the location was in top or bottom half\n\t\t// and also right or left half of the wheel, by adding 90, 180, 270 etc. Also for some the initial locationAngle needs to be inverted.\n\t\tif (topBottom == 'T' && leftRight == 'R') {\n\t\t\tlocationAngle = Math.round(90 - result)\n\t\t} else if (topBottom == 'B' && leftRight == 'R') {\n\t\t\tlocationAngle = Math.round(result + 90)\n\t\t} else if (topBottom == 'B' && leftRight == 'L') {\n\t\t\tlocationAngle = Math.round(90 - result + 180)\n\t\t} else if (topBottom == 'T' && leftRight == 'L') {\n\t\t\tlocationAngle = Math.round(result + 270)\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// And now we have to adjust to make sense when the wheel is rotated from the 0 degrees either\n\t\t// positive or negative and it can be many times past 360 degrees.\n\t\tif (this.rotationAngle != 0) {\n\t\t\tvar rotatedPosition = this.getRotationPosition()\n\n\t\t\t// So we have this, now we need to alter the locationAngle as a result of this.\n\t\t\tlocationAngle = locationAngle - rotatedPosition\n\n\t\t\t// If negative then take the location away from 360.\n\t\t\tif (locationAngle < 0) {\n\t\t\t\tlocationAngle = 360 - Math.abs(locationAngle)\n\t\t\t}\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// OK, so after all of that we have the angle of a line between the centerX and centerY of the wheel and\n\t\t// the X and Y of the location on the canvas where the mouse was clicked. Now time to work out the segment\n\t\t// this corresponds to. We can use the segment start and end angles for this.\n\t\tvar foundSegmentNumber = null\n\n\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t// Due to segments sharing start and end angles, if line is clicked will pick earlier segment.\n\t\t\tif (locationAngle >= this.segments[x].startAngle && locationAngle <= this.segments[x].endAngle) {\n\t\t\t\t// To ensure that a click anywhere on the canvas in the segment direction will not cause a\n\t\t\t\t// segment to be matched, as well as the angles, we need to ensure the click was within the radius\n\t\t\t\t// of the segment (or circle if no segment radius).\n\n\t\t\t\t// If the hypotenuseSideLength (length of location from the center of the wheel) is with the radius\n\t\t\t\t// then we can assign the segment to the found segment and break out the loop.\n\n\t\t\t\t// Have to take in to account hollow wheels (doughnuts) so check is greater than innerRadius as\n\t\t\t\t// well as less than or equal to the outerRadius of the wheel.\n\t\t\t\tif (hypotenuseSideLength >= this.innerRadius && hypotenuseSideLength <= this.outerRadius) {\n\t\t\t\t\tfoundSegmentNumber = x\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Finally return the number.\n\t\treturn foundSegmentNumber\n\t}\n\n\t// ====================================================================================================================\n\t// Returns a reference to the segment that is at the location of the pointer on the wheel.\n\t// ====================================================================================================================\n\tgetIndicatedSegment() {\n\t\t// Call function below to work this out and return the prizeNumber.\n\t\tvar prizeNumber = this.getIndicatedSegmentNumber()\n\n\t\t// Then simply return the segment in the segments array at that position.\n\t\treturn this.segments[prizeNumber]\n\t}\n\n\t// ====================================================================================================================\n\t// Works out the segment currently pointed to by the pointer of the wheel. Normally called when the spinning has stopped\n\t// to work out the prize the user has won. Returns the number of the segment in the segments array.\n\t// ====================================================================================================================\n\tgetIndicatedSegmentNumber() {\n\t\tvar indicatedPrize = 0\n\t\tvar rawAngle = this.getRotationPosition()\n\n\t\t// Now we have the angle of the wheel, but we need to take in to account where the pointer is because\n\t\t// will not always be at the 12 o'clock 0 degrees location.\n\t\tvar relativeAngle = Math.floor(this.pointerAngle - rawAngle)\n\n\t\tif (relativeAngle < 0) {\n\t\t\trelativeAngle = 360 - Math.abs(relativeAngle)\n\t\t}\n\n\t\t// Now we can work out the prize won by seeing what prize segment startAngle and endAngle the relativeAngle is between.\n\t\tfor (var x = 1; x < this.segments.length; x++) {\n\t\t\tif (relativeAngle >= this.segments[x]['startAngle'] && relativeAngle <= this.segments[x]['endAngle']) {\n\t\t\t\tindicatedPrize = x\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn indicatedPrize\n\t}\n\n\t// ====================================================================================================================\n\t// Works out what Pin around the wheel is considered the current one which is the one which just passed the pointer.\n\t// Used to work out if the pin has changed during the animation to tigger a sound.\n\t// ====================================================================================================================\n\tgetCurrentPinNumber() {\n\t\tvar currentPin = 0\n\n\t\tif (this.pins) {\n\t\t\tvar rawAngle = this.getRotationPosition()\n\n\t\t\t// Now we have the angle of the wheel, but we need to take in to account where the pointer is because\n\t\t\t// will not always be at the 12 o'clock 0 degrees location.\n\t\t\tvar relativeAngle = Math.floor(this.pointerAngle - rawAngle)\n\n\t\t\tif (relativeAngle < 0) {\n\t\t\t\trelativeAngle = 360 - Math.abs(relativeAngle)\n\t\t\t}\n\n\t\t\t// Work out the angle of the pins as this is simply 360 / the number of pins as they space evenly around.\n\t\t\tvar pinSpacing = 360 / this.pins.number\n\t\t\tvar totalPinAngle = 0\n\n\t\t\t// Now we can work out the pin by seeing what pins relativeAngle is between.\n\t\t\tfor (var x = 0; x < this.pins.number; x++) {\n\t\t\t\tif (relativeAngle >= totalPinAngle && relativeAngle <= totalPinAngle + pinSpacing) {\n\t\t\t\t\tcurrentPin = x\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\ttotalPinAngle += pinSpacing\n\t\t\t}\n\n\t\t\t// Now if rotating clockwise we must add 1 to the current pin as we want the pin which has just passed\n\t\t\t// the pointer to be returned as the current pin, not the start of the one we are between.\n\t\t\tif (this.animation.direction == 'clockwise') {\n\t\t\t\tcurrentPin++\n\n\t\t\t\tif (currentPin > this.pins.number) {\n\t\t\t\t\tcurrentPin = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn currentPin\n\t}\n\n\t// ==================================================================================================================================================\n\t// Returns the rotation angle of the wheel corrected to 0-360 (i.e. removes all the multiples of 360).\n\t// ==================================================================================================================================================\n\tgetRotationPosition() {\n\t\tvar rawAngle = this.rotationAngle // Get current rotation angle of wheel.\n\n\t\t// If positive work out how many times past 360 this is and then take the floor of this off the rawAngle.\n\t\tif (rawAngle >= 0) {\n\t\t\tif (rawAngle > 360) {\n\t\t\t\t// Get floor of the number of times past 360 degrees.\n\t\t\t\tvar timesPast360 = Math.floor(rawAngle / 360)\n\n\t\t\t\t// Take all this extra off to get just the angle 0-360 degrees.\n\t\t\t\trawAngle = rawAngle - 360 * timesPast360\n\t\t\t}\n\t\t} else {\n\t\t\t// Is negative, need to take off the extra then convert in to 0-360 degree value\n\t\t\t// so if, for example, was -90 then final value will be (360 - 90) = 270 degrees.\n\t\t\tif (rawAngle < -360) {\n\t\t\t\tvar timesPast360 = Math.ceil(rawAngle / 360) // Ceil when negative.\n\n\t\t\t\trawAngle = rawAngle - 360 * timesPast360 // Is minus because dealing with negative.\n\t\t\t}\n\n\t\t\trawAngle = 360 + rawAngle // Make in the range 0-360. Is plus because raw is still negative.\n\t\t}\n\n\t\treturn rawAngle\n\t}\n\n\t// ==================================================================================================================================================\n\t// This function starts the wheel's animation by using the properties of the animation object of of the wheel to begin the a greensock tween.\n\t// ==================================================================================================================================================\n\tstartAnimation() {\n\t\tif (this.animation) {\n\t\t\t// Call function to compute the animation properties.\n\t\t\tthis.computeAnimation()\n\n\t\t\t// Set this global variable to this object as an external function is required to call the draw() function on the wheel\n\t\t\t// each loop of the animation as Greensock cannot call the draw function directly on this class.\n\t\t\twinwheelToDrawDuringAnimation = this\n\n\t\t\t// Put together the properties of the greesock animation.\n\t\t\tvar properties = new Array(null)\n\t\t\tproperties[this.animation.propertyName] = this.animation.propertyValue // Here we set the property to be animated and its value.\n\t\t\tproperties['yoyo'] = this.animation.yoyo // Set others.\n\t\t\tproperties['repeat'] = this.animation.repeat\n\t\t\tproperties['ease'] = this.animation.easing\n\t\t\tproperties['onUpdate'] = winwheelAnimationLoop // Call function to re-draw the canvas.\n\t\t\tproperties['onComplete'] = winwheelStopAnimation // Call function to perform actions when animation has finished.\n\n\t\t\t// Do the tween animation passing the properties from the animation object as an array of key => value pairs.\n\t\t\t// Keep reference to the tween object in the wheel as that allows pausing, resuming, and stopping while the animation is still running.\n\t\t\tthis.tween = TweenMax.to(this, this.animation.duration, properties)\n\t\t}\n\t}\n\n\t// ==================================================================================================================================================\n\t// Use same function function which needs to be outside the class for the callback when it stops because is finished.\n\t// ==================================================================================================================================================\n\tstopAnimation(canCallback) {\n\t\t// @TODO as part of multiwheel, need to work out how to stop the tween for a single wheel but allow others to continue.\n\n\t\t// We can kill the animation using our tween object.\n\t\tif (winwheelToDrawDuringAnimation) {\n\t\t\twinwheelToDrawDuringAnimation.tween.kill()\n\n\t\t\t// Call the callback function.\n\t\t\twinwheelStopAnimation(canCallback)\n\t\t}\n\n\t\t// Ensure the winwheelToDrawDuringAnimation is set to this class.\n\t\twinwheelToDrawDuringAnimation = this\n\t}\n\n\t// ==================================================================================================================================================\n\t// Pause animation by telling tween to pause.\n\t// ==================================================================================================================================================\n\tpauseAnimation() {\n\t\tif (this.tween) {\n\t\t\tthis.tween.pause()\n\t\t}\n\t}\n\n\t// ==================================================================================================================================================\n\t// Resume the animation by telling tween to continue playing it.\n\t// ==================================================================================================================================================\n\tresumeAnimation() {\n\t\tif (this.tween) {\n\t\t\tthis.tween.play()\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// Called at the beginning of the startAnimation function and computes the values needed to do the animation\n\t// before it starts. This allows the developer to change the animation properties after the wheel has been created\n\t// and have the animation use the new values of the animation properties.\n\t// ====================================================================================================================\n\tcomputeAnimation() {\n\t\tif (this.animation) {\n\t\t\t// Set the animation parameters for the specified animation type including some sensible defaults if values have not been specified.\n\t\t\tif (this.animation.type == 'spinOngoing') {\n\t\t\t\t// When spinning the rotationAngle is the wheel property which is animated.\n\t\t\t\tthis.animation.propertyName = 'rotationAngle'\n\n\t\t\t\tif (this.animation.spins == null) {\n\t\t\t\t\tthis.animation.spins = 5\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.repeat == null) {\n\t\t\t\t\tthis.animation.repeat = -1 // -1 means it will repeat forever.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.easing == null) {\n\t\t\t\t\tthis.animation.easing = 'Linear.easeNone'\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.yoyo == null) {\n\t\t\t\t\tthis.animation.yoyo = false\n\t\t\t\t}\n\n\t\t\t\t// We need to calculate the propertyValue and this is the spins * 360 degrees.\n\t\t\t\tthis.animation.propertyValue = this.animation.spins * 360\n\n\t\t\t\t// If the direction is anti-clockwise then make the property value negative.\n\t\t\t\tif (this.animation.direction == 'anti-clockwise') {\n\t\t\t\t\tthis.animation.propertyValue = 0 - this.animation.propertyValue\n\t\t\t\t}\n\t\t\t} else if (this.animation.type == 'spinToStop') {\n\t\t\t\t// Spin to stop the rotation angle is affected.\n\t\t\t\tthis.animation.propertyName = 'rotationAngle'\n\n\t\t\t\tif (this.animation.spins == null) {\n\t\t\t\t\tthis.animation.spins = 5\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.repeat == null) {\n\t\t\t\t\tthis.animation.repeat = 0 // As this is spin to stop we don't normally want it repeated.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.easing == null) {\n\t\t\t\t\tthis.animation.easing = 'Power3.easeOut' // This easing is fast start and slows over time.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.stopAngle == null) {\n\t\t\t\t\t// If the stop angle has not been specified then pick random between 0 and 359.\n\t\t\t\t\tthis.animation._stopAngle = Math.floor(Math.random() * 359)\n\t\t\t\t} else {\n\t\t\t\t\t// We need to set the internal to 360 minus what the user entered because the wheel spins past 0 without\n\t\t\t\t\t// this it would indicate the prize on the opposite side of the wheel. We aslo need to take in to account\n\t\t\t\t\t// the pointerAngle as the stop angle needs to be relative to that.\n\t\t\t\t\tthis.animation._stopAngle = 360 - this.animation.stopAngle + this.pointerAngle\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.yoyo == null) {\n\t\t\t\t\tthis.animation.yoyo = false\n\t\t\t\t}\n\n\t\t\t\t// The property value is the spins * 360 then plus or minus the stopAngle depending on if the rotation is clockwise or anti-clockwise.\n\t\t\t\tthis.animation.propertyValue = this.animation.spins * 360\n\n\t\t\t\tif (this.animation.direction == 'anti-clockwise') {\n\t\t\t\t\tthis.animation.propertyValue = 0 - this.animation.propertyValue\n\n\t\t\t\t\t// Also if the value is anti-clockwise we need subtract the stopAngle (but to get the wheel to stop in the correct\n\t\t\t\t\t// place this is 360 minus the stop angle as the wheel is rotating backwards).\n\t\t\t\t\tthis.animation.propertyValue -= 360 - this.animation._stopAngle\n\t\t\t\t} else {\n\t\t\t\t\t// Add the stopAngle to the propertyValue as the wheel must rotate around to this place and stop there.\n\t\t\t\t\tthis.animation.propertyValue += this.animation._stopAngle\n\t\t\t\t}\n\t\t\t} else if (this.animation.type == 'spinAndBack') {\n\t\t\t\t// This is basically is a spin for a number of times then the animation reverses and goes back to start.\n\t\t\t\t// If a repeat is specified then this can be used to make the wheel \"rock\" left and right.\n\n\t\t\t\t// Again this is a spin so the rotationAngle the property which is animated.\n\t\t\t\tthis.animation.propertyName = 'rotationAngle'\n\n\t\t\t\tif (this.animation.spins == null) {\n\t\t\t\t\tthis.animation.spins = 5\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.repeat == null) {\n\t\t\t\t\tthis.animation.repeat = 1 // This needs to be set to at least 1 in order for the animation to reverse.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.easing == null) {\n\t\t\t\t\tthis.animation.easing = 'Power2.easeInOut' // This is slow at the start and end and fast in the middle.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.yoyo == null) {\n\t\t\t\t\tthis.animation.yoyo = true // This needs to be set to true to have the animation reverse back like a yo-yo.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.stopAngle == null) {\n\t\t\t\t\tthis.animation._stopAngle = 0\n\t\t\t\t} else {\n\t\t\t\t\t// We need to set the internal to 360 minus what the user entered\n\t\t\t\t\t// because the wheel spins past 0 without this it would indicate the\n\t\t\t\t\t// prize on the opposite side of the wheel.\n\t\t\t\t\tthis.animation._stopAngle = 360 - this.animation.stopAngle\n\t\t\t\t}\n\n\t\t\t\t// The property value is the spins * 360 then plus or minus the stopAngle depending on if the rotation is clockwise or anti-clockwise.\n\t\t\t\tthis.animation.propertyValue = this.animation.spins * 360\n\n\t\t\t\tif (this.animation.direction == 'anti-clockwise') {\n\t\t\t\t\tthis.animation.propertyValue = 0 - this.animation.propertyValue\n\n\t\t\t\t\t// Also if the value is anti-clockwise we need subtract the stopAngle (but to get the wheel to stop in the correct\n\t\t\t\t\t// place this is 360 minus the stop angle as the wheel is rotating backwards).\n\t\t\t\t\tthis.animation.propertyValue -= 360 - this.animation._stopAngle\n\t\t\t\t} else {\n\t\t\t\t\t// Add the stopAngle to the propertyValue as the wheel must rotate around to this place and stop there.\n\t\t\t\t\tthis.animation.propertyValue += this.animation._stopAngle\n\t\t\t\t}\n\t\t\t} else if (this.animation.type == 'custom') {\n\t\t\t\t// Do nothing as all values must be set by the developer in the parameters\n\t\t\t\t// especially the propertyName and propertyValue.\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// Calculates and returns a random stop angle inside the specified segment number. Value will always be 1 degree inside\n\t// the start and end of the segment to avoid issue with the segment overlap.\n\t// ====================================================================================================================\n\tgetRandomForSegment(segmentNumber) {\n\t\tvar stopAngle = 0\n\n\t\tif (segmentNumber) {\n\t\t\tif (typeof this.segments[segmentNumber] !== 'undefined') {\n\t\t\t\tvar startAngle = this.segments[segmentNumber].startAngle\n\t\t\t\tvar endAngle = this.segments[segmentNumber].endAngle\n\t\t\t\tvar range = endAngle - startAngle - 2\n\n\t\t\t\tif (range > 0) {\n\t\t\t\t\tstopAngle = startAngle + 1 + Math.floor(Math.random() * range)\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log('Segment size is too small to safely get random angle inside it')\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.log('Segment ' + segmentNumber + ' undefined')\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log('Segment number not specified')\n\t\t}\n\n\t\treturn stopAngle\n\t}\n}\n\n// ====================================================================================================================\n// Class for the wheel pins.\n// ====================================================================================================================\nexport class Pin {\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tvisible: true, // In future there might be some functionality related to the pins even if they are not displayed.\n\t\t\tnumber: 36, // The number of pins. These are evenly distributed around the wheel.\n\t\t\touterRadius: 3, // Radius of the pins which determines their size.\n\t\t\tfillStyle: 'grey', // Fill colour of the pins.\n\t\t\tstrokeStyle: 'black', // Line colour of the pins.\n\t\t\tlineWidth: 1, // Line width of the pins.\n\t\t\tmargin: 3, // The space between outside edge of the wheel and the pins.\n\t\t}\n\n\t\t// Now loop through the default options and create properties of this class set to the value for\n\t\t// the option passed in if a value was, or if not then set the value of the default.\n\t\tfor (var key in defaultOptions) {\n\t\t\tif (options != null && typeof options[key] !== 'undefined') this[key] = options[key]\n\t\t\telse this[key] = defaultOptions[key]\n\t\t}\n\n\t\t// Also loop though the passed in options and add anything specified not part of the class in to it as a property.\n\t\tif (options != null) {\n\t\t\tfor (var key in options) {\n\t\t\t\tif (typeof this[key] === 'undefined') {\n\t\t\t\t\tthis[key] = options[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n// ====================================================================================================================\n// Class for the wheel spinning animation which like a segment becomes a property of the wheel.\n// ====================================================================================================================\nexport class Animation {\n\tconstructor(options) {\n\t\t// Most of these options are null because the defaults are different depending on the type of animation.\n\t\tvar defaultOptions = {\n\t\t\ttype: 'spinOngoing', // For now there are only supported types are spinOngoing (continuous), spinToStop, spinAndBack, custom.\n\t\t\tdirection: 'clockwise', // clockwise or anti-clockwise.\n\t\t\tpropertyName: null, // The name of the winning wheel property to be affected by the animation.\n\t\t\tpropertyValue: null, // The value the property is to be set to at the end of the animation.\n\t\t\tduration: 10, // Duration of the animation.\n\t\t\tyoyo: false, // If the animation is to reverse back again i.e. yo-yo.\n\t\t\trepeat: null, // The number of times the animation is to repeat, -1 will cause it to repeat forever.\n\t\t\teasing: null, // The easing to use for the animation, default is the best for spin to stop. Use Linear.easeNone for no easing.\n\t\t\tstopAngle: null, // Used for spinning, the angle at which the wheel is to stop.\n\t\t\tspins: null, // Used for spinning, the number of complete 360 degree rotations the wheel is to do.\n\t\t\tclearTheCanvas: null, // If set to true the canvas will be cleared before the wheel is re-drawn, false it will not, null the animation will abide by the value of this property for the parent wheel object.\n\t\t\tcallbackFinished: null, // Function to callback when the animation has finished.\n\t\t\tcallbackBefore: null, // Function to callback before the wheel is drawn each animation loop.\n\t\t\tcallbackAfter: null, // Function to callback after the wheel is drawn each animation loop.\n\t\t\tcallbackSound: null, // Function to callback if a sound should be triggered on change of segment or pin.\n\t\t\tsoundTrigger: 'segment', // Sound trigger type. Default is segment which triggers when segment changes, can be pin if to trigger when pin passes the pointer.\n\t\t}\n\n\t\t// Now loop through the default options and create properties of this class set to the value for\n\t\t// the option passed in if a value was, or if not then set the value of the default.\n\t\tfor (var key in defaultOptions) {\n\t\t\tif (options != null && typeof options[key] !== 'undefined') this[key] = options[key]\n\t\t\telse this[key] = defaultOptions[key]\n\t\t}\n\n\t\t// Also loop though the passed in options and add anything specified not part of the class in to it as a property.\n\t\tif (options != null) {\n\t\t\tfor (var key in options) {\n\t\t\t\tif (typeof this[key] === 'undefined') {\n\t\t\t\t\tthis[key] = options[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n// ====================================================================================================================\n// Class for segments. When creating a json of options can be passed in.\n// ====================================================================================================================\nexport class Segment {\n\tconstructor(options) {\n\t\t// Define default options for segments, most are null so that the global defaults for the wheel\n\t\t// are used if the values for a particular segment are not specifically set.\n\t\tvar defaultOptions = {\n\t\t\tsize: null, // Leave null for automatic. Valid values are degrees 0-360. Use percentToDegrees function if needed to convert.\n\t\t\ttext: '', // Default is blank.\n\t\t\tfillStyle: null, // If null for the rest the global default will be used.\n\t\t\tstrokeStyle: null,\n\t\t\tlineWidth: null,\n\t\t\ttextFontFamily: null,\n\t\t\ttextFontSize: null,\n\t\t\ttextFontWeight: null,\n\t\t\ttextOrientation: null,\n\t\t\ttextAlignment: null,\n\t\t\ttextDirection: null,\n\t\t\ttextMargin: null,\n\t\t\ttextFillStyle: null,\n\t\t\ttextStrokeStyle: null,\n\t\t\ttextLineWidth: null,\n\t\t\timage: null, // Name/path to the image\n\t\t\timageDirection: null, // Direction of the image, can be set globally for the whole wheel.\n\t\t\timgData: null, // Image object created here and loaded with image data.\n\t\t}\n\n\t\t// Now loop through the default options and create properties of this class set to the value for\n\t\t// the option passed in if a value was, or if not then set the value of the default.\n\t\tfor (var key in defaultOptions) {\n\t\t\tif (options != null && typeof options[key] !== 'undefined') this[key] = options[key]\n\t\t\telse this[key] = defaultOptions[key]\n\t\t}\n\n\t\t// Also loop though the passed in options and add anything specified not part of the class in to it as a property.\n\t\t// This allows the developer to easily add properties to segments at construction time.\n\t\tif (options != null) {\n\t\t\tfor (var key in options) {\n\t\t\t\tif (typeof this[key] === 'undefined') {\n\t\t\t\t\tthis[key] = options[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// There are 2 additional properties which are set by the code, so need to define them here.\n\t\t// They are not in the default options because they are not something that should be set by the user,\n\t\t// the values are updated every time the updateSegmentSizes() function is called.\n\t\tthis.startAngle = 0\n\t\tthis.endAngle = 0\n\t}\n\n\t// ====================================================================================================================\n\t// Changes an image for a segment by setting a callback to render the wheel once the image has loaded.\n\t// ====================================================================================================================\n\tchangeImage(image, imageDirection) {\n\t\t// Change image name, blank image data.\n\t\tthis.image = image\n\t\tthis.imgData = null\n\n\t\t// Set direction.\n\t\tif (imageDirection) {\n\t\t\tthis.imageDirection = imageDirection\n\t\t}\n\n\t\t// Set imgData to a new image object, change set callback and change src (just like in wheel constructor).\n\t\twinhweelAlreadyDrawn = false\n\t\tthis.imgData = new Image()\n\t\tthis.imgData.onload = winwheelLoadedImage\n\t\tthis.imgData.src = this.image\n\t}\n}\n\n// ====================================================================================================================\n// Class that is created as property of the wheel. Draws line from center of the wheel out to edge of canvas to\n// indicate where the code thinks the pointer location is. Helpful to get alignment correct esp when using images.\n// ====================================================================================================================\nexport class PointerGuide {\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tdisplay: false,\n\t\t\tstrokeStyle: 'red',\n\t\t\tlineWidth: 3,\n\t\t}\n\n\t\t// Now loop through the default options and create properties of this class set to the value for\n\t\t// the option passed in if a value was, or if not then set the value of the default.\n\t\tfor (var key in defaultOptions) {\n\t\t\tif (options != null && typeof options[key] !== 'undefined') {\n\t\t\t\tthis[key] = options[key]\n\t\t\t} else {\n\t\t\t\tthis[key] = defaultOptions[key]\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ====================================================================================================================\n// This function takes the percent 0-100 and returns the number of degrees 0-360 this equates to.\n// ====================================================================================================================\nfunction winwheelPercentToDegrees(percentValue) {\n\tvar degrees = 0\n\n\tif (percentValue > 0 && percentValue <= 100) {\n\t\tvar divider = percentValue / 100\n\t\tdegrees = 360 * divider\n\t}\n\n\treturn degrees\n}\n\n// ====================================================================================================================\n// In order for the wheel to be re-drawn during the spin animation the function greesock calls needs to be outside\n// of the class as for some reason it errors if try to call winwheel.draw() directly.\n// ====================================================================================================================\nfunction winwheelAnimationLoop() {\n\tif (winwheelToDrawDuringAnimation) {\n\t\t// Check if the clearTheCanvas is specified for this animation, if not or it is not false then clear the canvas.\n\t\tif (winwheelToDrawDuringAnimation.animation.clearTheCanvas != false) {\n\t\t\twinwheelToDrawDuringAnimation.ctx.clearRect(\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\twinwheelToDrawDuringAnimation.canvas.width,\n\t\t\t\twinwheelToDrawDuringAnimation.canvas.height\n\t\t\t)\n\t\t}\n\n\t\tvar callbackBefore = winwheelToDrawDuringAnimation.animation.callbackBefore\n\t\tvar callbackAfter = winwheelToDrawDuringAnimation.animation.callbackAfter\n\n\t\t// If there is a callback function which is supposed to be called before the wheel is drawn then do that.\n\t\tif (callbackBefore != null) {\n\t\t\t// If the property is a function then call it, otherwise eval the proptery as javascript code.\n\t\t\tif (typeof callbackBefore === 'function') {\n\t\t\t\tcallbackBefore()\n\t\t\t} else {\n\t\t\t\teval(callbackBefore)\n\t\t\t}\n\t\t}\n\n\t\t// Call code to draw the wheel, pass in false as we never want it to clear the canvas as that would wipe anything drawn in the callbackBefore.\n\t\twinwheelToDrawDuringAnimation.draw(false)\n\n\t\t// If there is a callback function which is supposed to be called after the wheel has been drawn then do that.\n\t\tif (callbackAfter != null) {\n\t\t\t// If the property is a function then call it, otherwise eval the proptery as javascript code.\n\t\t\tif (typeof callbackAfter === 'function') {\n\t\t\t\tcallbackAfter()\n\t\t\t} else {\n\t\t\t\teval(callbackAfter)\n\t\t\t}\n\t\t}\n\n\t\t// If there is a sound callback then call a function which figures out if the sound should be triggered\n\t\t// and if so then call the function specified by the developer.\n\t\tif (winwheelToDrawDuringAnimation.animation.callbackSound) {\n\t\t\twinwheelTriggerSound()\n\t\t}\n\t}\n}\n\n// ====================================================================================================================\n// This function figures out if the callbackSound function needs to be called by working out if the segment or pin\n// has changed since the last animation loop.\n// ====================================================================================================================\nfunction winwheelTriggerSound() {\n\t// If this property does not exist then add it as a property of the winwheel.\n\tif (winwheelToDrawDuringAnimation.hasOwnProperty('_lastSoundTriggerNumber') == false) {\n\t\twinwheelToDrawDuringAnimation._lastSoundTriggerNumber = 0\n\t}\n\n\tvar callbackSound = winwheelToDrawDuringAnimation.animation.callbackSound\n\tvar currentTriggerNumber = 0\n\n\t// Now figure out if the sound callback should be called depending on the sound trigger type.\n\tif (winwheelToDrawDuringAnimation.animation.soundTrigger == 'pin') {\n\t\t// So for the pin type we need to work out which pin we are between.\n\t\tcurrentTriggerNumber = winwheelToDrawDuringAnimation.getCurrentPinNumber()\n\t} else {\n\t\t// Check on the change of segment by working out which segment we are in.\n\t\t// We can utilise the existing getIndiatedSegmentNumber function.\n\t\tcurrentTriggerNumber = winwheelToDrawDuringAnimation.getIndicatedSegmentNumber()\n\t}\n\n\t// If the current number is not the same as last time then call the sound callback.\n\tif (currentTriggerNumber != winwheelToDrawDuringAnimation._lastSoundTriggerNumber) {\n\t\t// If the property is a function then call it, otherwise eval the proptery as javascript code.\n\t\tif (typeof callbackSound === 'function') {\n\t\t\tcallbackSound()\n\t\t} else {\n\t\t\teval(callbackSound)\n\t\t}\n\n\t\t// Also update the last sound trigger with the current number.\n\t\twinwheelToDrawDuringAnimation._lastSoundTriggerNumber = currentTriggerNumber\n\t}\n}\n\n// ====================================================================================================================\n// This function is called-back when the greensock animation has finished.\n// ====================================================================================================================\nvar winwheelToDrawDuringAnimation = null // This global is set by the winwheel class to the wheel object to be re-drawn.\n\nfunction winwheelStopAnimation(canCallback) {\n\t// When the animation is stopped if canCallback is not false then try to call the callback.\n\t// false can be passed in to stop the after happening if the animation has been stopped before it ended normally.\n\tif (canCallback != false) {\n\t\tvar callback = winwheelToDrawDuringAnimation.animation.callbackFinished\n\n\t\tif (callback != null) {\n\t\t\t// If the callback is a function then call it, otherwise evaluate the property as javascript code.\n\t\t\tif (typeof callback === 'function') {\n\t\t\t\t// Pass back the indicated segment as 99% of the time you will want to know this to inform the user of their prize.\n\t\t\t\tcallback(winwheelToDrawDuringAnimation.getIndicatedSegment())\n\t\t\t} else {\n\t\t\t\teval(callback)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ====================================================================================================================\n// Called after the image has loaded for each segment. Once all the images are loaded it then calls the draw function\n// on the wheel to render it. Used in constructor and also when a segment image is changed.\n// ====================================================================================================================\nvar winhweelAlreadyDrawn = false\n\nfunction winwheelLoadedImage() {\n\t// Prevent multiple drawings of the wheel which ocurrs without this check due to timing of function calls.\n\tif (winhweelAlreadyDrawn == false) {\n\t\t// Set to 0.\n\t\tvar winwheelImageLoadCount = 0\n\n\t\t// Loop though all the segments of the wheel and check if image data loaded, if so increment counter.\n\t\tfor (var i = 1; i <= winwheelToDrawDuringAnimation.numSegments; i++) {\n\t\t\t// Check the image data object is not null and also that the image has completed loading by checking\n\t\t\t// that a property of it such as the height has some sort of true value.\n\t\t\tif (\n\t\t\t\twinwheelToDrawDuringAnimation.segments[i].imgData != null &&\n\t\t\t\twinwheelToDrawDuringAnimation.segments[i].imgData.height\n\t\t\t) {\n\t\t\t\twinwheelImageLoadCount++\n\t\t\t}\n\t\t}\n\n\t\t// If number of images loaded matches the segments then all the images for the wheel are loaded.\n\t\tif (winwheelImageLoadCount == winwheelToDrawDuringAnimation.numSegments) {\n\t\t\t// Call draw function to render the wheel.\n\t\t\twinhweelAlreadyDrawn = true\n\t\t\twinwheelToDrawDuringAnimation.draw()\n\t\t}\n\t}\n}\n"],"sourceRoot":""}